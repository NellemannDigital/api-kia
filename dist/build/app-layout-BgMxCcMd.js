import { r as u, t as _s, j as c, d as A, U as xe, a as or } from "./compiler-runtime-DyHbwOGE.js";
import { a as ue, u as G, d as it, c as L, e as Rs, b as As, S as en, B as Ms, r as sr, f as ar, A as Ps } from "./app-logo-icon-CT5L2AiP.js";
import { d as ye, a as P, c as he, u as ht, P as de, e as Os, b as Ns } from "./index-CN0MIxF1.js";
import { P as B, d as ir } from "./index-Rx3-OPby.js";
import { R as Ts, r as Ds } from "./index-GQej7NOz.js";
import { a as tn, L as Fe, r as js } from "./app-mGJhb3YO.js";
import { q as nn, b as Is, d as cr } from "./index-DLuvQKrb.js";
const Ls = [
  ["path", { d: "M12 7v14", key: "1akyts" }],
  [
    "path",
    {
      d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",
      key: "ruj8y"
    }
  ]
], ks = ue("BookOpen", Ls);
const Fs = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], $s = ue("ChevronRight", Fs);
const Bs = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
], Hs = ue("ChevronsUpDown", Bs);
const Ws = [
  [
    "path",
    {
      d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
      key: "1kt360"
    }
  ]
], Gs = ue("Folder", Ws);
const Ks = [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
], Us = ue("LayoutGrid", Ks);
const Vs = [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
], zs = ue("LogOut", Vs);
const Ys = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
], qs = ue("PanelLeft", Ys);
const Xs = [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], Qs = ue("Settings", Xs);
const Zs = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Js = ue("X", Zs), ea = 768, rt = typeof window > "u" ? void 0 : window.matchMedia(`(max-width: ${ea - 1}px)`);
function ta(t) {
  return rt ? (rt.addEventListener("change", t), () => {
    rt.removeEventListener("change", t);
  }) : () => {
  };
}
function na() {
  return rt?.matches ?? !1;
}
function ra() {
  return !1;
}
function lr() {
  return u.useSyncExternalStore(ta, na, ra);
}
var oa = _s[" useId ".trim().toString()] || (() => {
}), sa = 0;
function be(t) {
  const [e, n] = u.useState(oa());
  return ye(() => {
    n((r) => r ?? String(sa++));
  }, [t]), t || (e ? `radix-${e}` : "");
}
function se(t) {
  const e = u.useRef(t);
  return u.useEffect(() => {
    e.current = t;
  }), u.useMemo(() => (...n) => e.current?.(...n), []);
}
function aa(t, e = globalThis?.document) {
  const n = se(t);
  u.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var ia = "DismissableLayer", Ut = "dismissableLayer.update", ca = "dismissableLayer.pointerDownOutside", la = "dismissableLayer.focusOutside", Pn, ur = u.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), vt = u.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: s,
      onInteractOutside: a,
      onDismiss: i,
      ...l
    } = t, f = u.useContext(ur), [d, p] = u.useState(null), m = d?.ownerDocument ?? globalThis?.document, [, h] = u.useState({}), g = G(e, (S) => p(S)), v = Array.from(f.layers), [x] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), b = v.indexOf(x), y = d ? v.indexOf(d) : -1, w = f.layersWithOutsidePointerEventsDisabled.size > 0, E = y >= b, C = fa((S) => {
      const M = S.target, O = [...f.branches].some((N) => N.contains(M));
      !E || O || (o?.(S), a?.(S), S.defaultPrevented || i?.());
    }, m), _ = pa((S) => {
      const M = S.target;
      [...f.branches].some((N) => N.contains(M)) || (s?.(S), a?.(S), S.defaultPrevented || i?.());
    }, m);
    return aa((S) => {
      y === f.layers.size - 1 && (r?.(S), !S.defaultPrevented && i && (S.preventDefault(), i()));
    }, m), u.useEffect(() => {
      if (d)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (Pn = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(d)), f.layers.add(d), On(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = Pn);
        };
    }, [d, m, n, f]), u.useEffect(() => () => {
      d && (f.layers.delete(d), f.layersWithOutsidePointerEventsDisabled.delete(d), On());
    }, [d, f]), u.useEffect(() => {
      const S = () => h({});
      return document.addEventListener(Ut, S), () => document.removeEventListener(Ut, S);
    }, []), /* @__PURE__ */ c.jsx(
      B.div,
      {
        ...l,
        ref: g,
        style: {
          pointerEvents: w ? E ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: P(t.onFocusCapture, _.onFocusCapture),
        onBlurCapture: P(t.onBlurCapture, _.onBlurCapture),
        onPointerDownCapture: P(
          t.onPointerDownCapture,
          C.onPointerDownCapture
        )
      }
    );
  }
);
vt.displayName = ia;
var ua = "DismissableLayerBranch", da = u.forwardRef((t, e) => {
  const n = u.useContext(ur), r = u.useRef(null), o = G(e, r);
  return u.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ c.jsx(B.div, { ...t, ref: o });
});
da.displayName = ua;
function fa(t, e = globalThis?.document) {
  const n = se(t), r = u.useRef(!1), o = u.useRef(() => {
  });
  return u.useEffect(() => {
    const s = (i) => {
      if (i.target && !r.current) {
        let l = function() {
          dr(
            ca,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: i };
        i.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = l, e.addEventListener("click", o.current, { once: !0 })) : l();
      } else
        e.removeEventListener("click", o.current);
      r.current = !1;
    }, a = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(a), e.removeEventListener("pointerdown", s), e.removeEventListener("click", o.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function pa(t, e = globalThis?.document) {
  const n = se(t), r = u.useRef(!1);
  return u.useEffect(() => {
    const o = (s) => {
      s.target && !r.current && dr(la, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function On() {
  const t = new CustomEvent(Ut);
  document.dispatchEvent(t);
}
function dr(t, e, n, { discrete: r }) {
  const o = n.originalEvent.target, s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && o.addEventListener(t, e, { once: !0 }), r ? ir(o, s) : o.dispatchEvent(s);
}
var Dt = "focusScope.autoFocusOnMount", jt = "focusScope.autoFocusOnUnmount", Nn = { bubbles: !1, cancelable: !0 }, ma = "FocusScope", rn = u.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: s,
    ...a
  } = t, [i, l] = u.useState(null), f = se(o), d = se(s), p = u.useRef(null), m = G(e, (v) => l(v)), h = u.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  u.useEffect(() => {
    if (r) {
      let v = function(w) {
        if (h.paused || !i) return;
        const E = w.target;
        i.contains(E) ? p.current = E : fe(p.current, { select: !0 });
      }, x = function(w) {
        if (h.paused || !i) return;
        const E = w.relatedTarget;
        E !== null && (i.contains(E) || fe(p.current, { select: !0 }));
      }, b = function(w) {
        if (document.activeElement === document.body)
          for (const C of w)
            C.removedNodes.length > 0 && fe(i);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", x);
      const y = new MutationObserver(b);
      return i && y.observe(i, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", x), y.disconnect();
      };
    }
  }, [r, i, h.paused]), u.useEffect(() => {
    if (i) {
      Dn.add(h);
      const v = document.activeElement;
      if (!i.contains(v)) {
        const b = new CustomEvent(Dt, Nn);
        i.addEventListener(Dt, f), i.dispatchEvent(b), b.defaultPrevented || (ha(ya(fr(i)), { select: !0 }), document.activeElement === v && fe(i));
      }
      return () => {
        i.removeEventListener(Dt, f), setTimeout(() => {
          const b = new CustomEvent(jt, Nn);
          i.addEventListener(jt, d), i.dispatchEvent(b), b.defaultPrevented || fe(v ?? document.body, { select: !0 }), i.removeEventListener(jt, d), Dn.remove(h);
        }, 0);
      };
    }
  }, [i, f, d, h]);
  const g = u.useCallback(
    (v) => {
      if (!n && !r || h.paused) return;
      const x = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, b = document.activeElement;
      if (x && b) {
        const y = v.currentTarget, [w, E] = va(y);
        w && E ? !v.shiftKey && b === E ? (v.preventDefault(), n && fe(w, { select: !0 })) : v.shiftKey && b === w && (v.preventDefault(), n && fe(E, { select: !0 })) : b === y && v.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ c.jsx(B.div, { tabIndex: -1, ...a, ref: m, onKeyDown: g });
});
rn.displayName = ma;
function ha(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (fe(r, { select: e }), document.activeElement !== n) return;
}
function va(t) {
  const e = fr(t), n = Tn(e, t), r = Tn(e.reverse(), t);
  return [n, r];
}
function fr(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function Tn(t, e) {
  for (const n of t)
    if (!ga(n, { upTo: e })) return n;
}
function ga(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function xa(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function fe(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && xa(t) && e && t.select();
  }
}
var Dn = ba();
function ba() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = jn(t, e), t.unshift(e);
    },
    remove(e) {
      t = jn(t, e), t[0]?.resume();
    }
  };
}
function jn(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function ya(t) {
  return t.filter((e) => e.tagName !== "A");
}
var wa = "Portal", gt = u.forwardRef((t, e) => {
  const { container: n, ...r } = t, [o, s] = u.useState(!1);
  ye(() => s(!0), []);
  const a = n || o && globalThis?.document?.body;
  return a ? Ts.createPortal(/* @__PURE__ */ c.jsx(B.div, { ...r, ref: e }), a) : null;
});
gt.displayName = wa;
var It = 0;
function pr() {
  u.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? In()), document.body.insertAdjacentElement("beforeend", t[1] ?? In()), It++, () => {
      It === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), It--;
    };
  }, []);
}
function In() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var ne = function() {
  return ne = Object.assign || function(e) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, ne.apply(this, arguments);
};
function mr(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
      e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n;
}
function Ea(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, o = e.length, s; r < o; r++)
    (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var ot = "right-scroll-bar-position", st = "width-before-scroll-bar", Ca = "with-scroll-bars-hidden", Sa = "--removed-body-scroll-bar-size";
function Lt(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function _a(t, e) {
  var n = u.useState(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var Ra = typeof window < "u" ? u.useLayoutEffect : u.useEffect, Ln = /* @__PURE__ */ new WeakMap();
function Aa(t, e) {
  var n = _a(null, function(r) {
    return t.forEach(function(o) {
      return Lt(o, r);
    });
  });
  return Ra(function() {
    var r = Ln.get(n);
    if (r) {
      var o = new Set(r), s = new Set(t), a = n.current;
      o.forEach(function(i) {
        s.has(i) || Lt(i, null);
      }), s.forEach(function(i) {
        o.has(i) || Lt(i, a);
      });
    }
    Ln.set(n, t);
  }, [t]), n;
}
function Ma(t) {
  return t;
}
function Pa(t, e) {
  e === void 0 && (e = Ma);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(s) {
      var a = e(s, r);
      return n.push(a), function() {
        n = n.filter(function(i) {
          return i !== a;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(s);
      }
      n = {
        push: function(i) {
          return s(i);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var a = [];
      if (n.length) {
        var i = n;
        n = [], i.forEach(s), a = n;
      }
      var l = function() {
        var d = a;
        a = [], d.forEach(s);
      }, f = function() {
        return Promise.resolve().then(l);
      };
      f(), n = {
        push: function(d) {
          a.push(d), f();
        },
        filter: function(d) {
          return a = a.filter(d), n;
        }
      };
    }
  };
  return o;
}
function Oa(t) {
  t === void 0 && (t = {});
  var e = Pa(null);
  return e.options = ne({ async: !0, ssr: !1 }, t), e;
}
var hr = function(t) {
  var e = t.sideCar, n = mr(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return u.createElement(r, ne({}, n));
};
hr.isSideCarExport = !0;
function Na(t, e) {
  return t.useMedium(e), hr;
}
var vr = Oa(), kt = function() {
}, xt = u.forwardRef(function(t, e) {
  var n = u.useRef(null), r = u.useState({
    onScrollCapture: kt,
    onWheelCapture: kt,
    onTouchMoveCapture: kt
  }), o = r[0], s = r[1], a = t.forwardProps, i = t.children, l = t.className, f = t.removeScrollBar, d = t.enabled, p = t.shards, m = t.sideCar, h = t.noRelative, g = t.noIsolation, v = t.inert, x = t.allowPinchZoom, b = t.as, y = b === void 0 ? "div" : b, w = t.gapMode, E = mr(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = m, _ = Aa([n, e]), S = ne(ne({}, E), o);
  return u.createElement(
    u.Fragment,
    null,
    d && u.createElement(C, { sideCar: vr, removeScrollBar: f, shards: p, noRelative: h, noIsolation: g, inert: v, setCallbacks: s, allowPinchZoom: !!x, lockRef: n, gapMode: w }),
    a ? u.cloneElement(u.Children.only(i), ne(ne({}, S), { ref: _ })) : u.createElement(y, ne({}, S, { className: l, ref: _ }), i)
  );
});
xt.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
xt.classNames = {
  fullWidth: st,
  zeroRight: ot
};
var Ta = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Da() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = Ta();
  return e && t.setAttribute("nonce", e), t;
}
function ja(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function Ia(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var La = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = Da()) && (ja(e, n), Ia(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, ka = function() {
  var t = La();
  return function(e, n) {
    u.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, gr = function() {
  var t = ka(), e = function(n) {
    var r = n.styles, o = n.dynamic;
    return t(r, o), null;
  };
  return e;
}, Fa = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Ft = function(t) {
  return parseInt(t || "", 10) || 0;
}, $a = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], o = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Ft(n), Ft(r), Ft(o)];
}, Ba = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return Fa;
  var e = $a(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, Ha = gr(), Me = "data-scroll-locked", Wa = function(t, e, n, r) {
  var o = t.left, s = t.top, a = t.right, i = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Ca, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(i, "px ").concat(r, `;
  }
  body[`).concat(Me, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(i, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(i, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ot, ` {
    right: `).concat(i, "px ").concat(r, `;
  }
  
  .`).concat(st, ` {
    margin-right: `).concat(i, "px ").concat(r, `;
  }
  
  .`).concat(ot, " .").concat(ot, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(st, " .").concat(st, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Me, `] {
    `).concat(Sa, ": ").concat(i, `px;
  }
`);
}, kn = function() {
  var t = parseInt(document.body.getAttribute(Me) || "0", 10);
  return isFinite(t) ? t : 0;
}, Ga = function() {
  u.useEffect(function() {
    return document.body.setAttribute(Me, (kn() + 1).toString()), function() {
      var t = kn() - 1;
      t <= 0 ? document.body.removeAttribute(Me) : document.body.setAttribute(Me, t.toString());
    };
  }, []);
}, Ka = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, o = r === void 0 ? "margin" : r;
  Ga();
  var s = u.useMemo(function() {
    return Ba(o);
  }, [o]);
  return u.createElement(Ha, { styles: Wa(s, !e, o, n ? "" : "!important") });
}, Vt = !1;
if (typeof window < "u")
  try {
    var Qe = Object.defineProperty({}, "passive", {
      get: function() {
        return Vt = !0, !0;
      }
    });
    window.addEventListener("test", Qe, Qe), window.removeEventListener("test", Qe, Qe);
  } catch {
    Vt = !1;
  }
var _e = Vt ? { passive: !1 } : !1, Ua = function(t) {
  return t.tagName === "TEXTAREA";
}, xr = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Ua(t) && n[e] === "visible")
  );
}, Va = function(t) {
  return xr(t, "overflowY");
}, za = function(t) {
  return xr(t, "overflowX");
}, Fn = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = br(t, r);
    if (o) {
      var s = yr(t, r), a = s[1], i = s[2];
      if (a > i)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Ya = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, qa = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, br = function(t, e) {
  return t === "v" ? Va(e) : za(e);
}, yr = function(t, e) {
  return t === "v" ? Ya(e) : qa(e);
}, Xa = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, Qa = function(t, e, n, r, o) {
  var s = Xa(t, window.getComputedStyle(e).direction), a = s * r, i = n.target, l = e.contains(i), f = !1, d = a > 0, p = 0, m = 0;
  do {
    if (!i)
      break;
    var h = yr(t, i), g = h[0], v = h[1], x = h[2], b = v - x - s * g;
    (g || b) && br(t, i) && (p += b, m += g);
    var y = i.parentNode;
    i = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
  } while (
    // portaled content
    !l && i !== document.body || // self content
    l && (e.contains(i) || e === i)
  );
  return (d && Math.abs(p) < 1 || !d && Math.abs(m) < 1) && (f = !0), f;
}, Ze = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, $n = function(t) {
  return [t.deltaX, t.deltaY];
}, Bn = function(t) {
  return t && "current" in t ? t.current : t;
}, Za = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, Ja = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, ei = 0, Re = [];
function ti(t) {
  var e = u.useRef([]), n = u.useRef([0, 0]), r = u.useRef(), o = u.useState(ei++)[0], s = u.useState(gr)[0], a = u.useRef(t);
  u.useEffect(function() {
    a.current = t;
  }, [t]), u.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = Ea([t.lockRef.current], (t.shards || []).map(Bn), !0).filter(Boolean);
      return v.forEach(function(x) {
        return x.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(x) {
          return x.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var i = u.useCallback(function(v, x) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !a.current.allowPinchZoom;
    var b = Ze(v), y = n.current, w = "deltaX" in v ? v.deltaX : y[0] - b[0], E = "deltaY" in v ? v.deltaY : y[1] - b[1], C, _ = v.target, S = Math.abs(w) > Math.abs(E) ? "h" : "v";
    if ("touches" in v && S === "h" && _.type === "range")
      return !1;
    var M = Fn(S, _);
    if (!M)
      return !0;
    if (M ? C = S : (C = S === "v" ? "h" : "v", M = Fn(S, _)), !M)
      return !1;
    if (!r.current && "changedTouches" in v && (w || E) && (r.current = C), !C)
      return !0;
    var O = r.current || C;
    return Qa(O, x, v, O === "h" ? w : E);
  }, []), l = u.useCallback(function(v) {
    var x = v;
    if (!(!Re.length || Re[Re.length - 1] !== s)) {
      var b = "deltaY" in x ? $n(x) : Ze(x), y = e.current.filter(function(C) {
        return C.name === x.type && (C.target === x.target || x.target === C.shadowParent) && Za(C.delta, b);
      })[0];
      if (y && y.should) {
        x.cancelable && x.preventDefault();
        return;
      }
      if (!y) {
        var w = (a.current.shards || []).map(Bn).filter(Boolean).filter(function(C) {
          return C.contains(x.target);
        }), E = w.length > 0 ? i(x, w[0]) : !a.current.noIsolation;
        E && x.cancelable && x.preventDefault();
      }
    }
  }, []), f = u.useCallback(function(v, x, b, y) {
    var w = { name: v, delta: x, target: b, should: y, shadowParent: ni(b) };
    e.current.push(w), setTimeout(function() {
      e.current = e.current.filter(function(E) {
        return E !== w;
      });
    }, 1);
  }, []), d = u.useCallback(function(v) {
    n.current = Ze(v), r.current = void 0;
  }, []), p = u.useCallback(function(v) {
    f(v.type, $n(v), v.target, i(v, t.lockRef.current));
  }, []), m = u.useCallback(function(v) {
    f(v.type, Ze(v), v.target, i(v, t.lockRef.current));
  }, []);
  u.useEffect(function() {
    return Re.push(s), t.setCallbacks({
      onScrollCapture: p,
      onWheelCapture: p,
      onTouchMoveCapture: m
    }), document.addEventListener("wheel", l, _e), document.addEventListener("touchmove", l, _e), document.addEventListener("touchstart", d, _e), function() {
      Re = Re.filter(function(v) {
        return v !== s;
      }), document.removeEventListener("wheel", l, _e), document.removeEventListener("touchmove", l, _e), document.removeEventListener("touchstart", d, _e);
    };
  }, []);
  var h = t.removeScrollBar, g = t.inert;
  return u.createElement(
    u.Fragment,
    null,
    g ? u.createElement(s, { styles: Ja(o) }) : null,
    h ? u.createElement(Ka, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function ni(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const ri = Na(vr, ti);
var on = u.forwardRef(function(t, e) {
  return u.createElement(xt, ne({}, t, { ref: e, sideCar: ri }));
});
on.classNames = xt.classNames;
var oi = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Ae = /* @__PURE__ */ new WeakMap(), Je = /* @__PURE__ */ new WeakMap(), et = {}, $t = 0, wr = function(t) {
  return t && (t.host || wr(t.parentNode));
}, si = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = wr(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, ai = function(t, e, n, r) {
  var o = si(e, Array.isArray(t) ? t : [t]);
  et[n] || (et[n] = /* @__PURE__ */ new WeakMap());
  var s = et[n], a = [], i = /* @__PURE__ */ new Set(), l = new Set(o), f = function(p) {
    !p || i.has(p) || (i.add(p), f(p.parentNode));
  };
  o.forEach(f);
  var d = function(p) {
    !p || l.has(p) || Array.prototype.forEach.call(p.children, function(m) {
      if (i.has(m))
        d(m);
      else
        try {
          var h = m.getAttribute(r), g = h !== null && h !== "false", v = (Ae.get(m) || 0) + 1, x = (s.get(m) || 0) + 1;
          Ae.set(m, v), s.set(m, x), a.push(m), v === 1 && g && Je.set(m, !0), x === 1 && m.setAttribute(n, "true"), g || m.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", m, b);
        }
    });
  };
  return d(e), i.clear(), $t++, function() {
    a.forEach(function(p) {
      var m = Ae.get(p) - 1, h = s.get(p) - 1;
      Ae.set(p, m), s.set(p, h), m || (Je.has(p) || p.removeAttribute(r), Je.delete(p)), h || p.removeAttribute(n);
    }), $t--, $t || (Ae = /* @__PURE__ */ new WeakMap(), Ae = /* @__PURE__ */ new WeakMap(), Je = /* @__PURE__ */ new WeakMap(), et = {});
  };
}, Er = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), o = oi(t);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), ai(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, bt = "Dialog", [Cr, hf] = he(bt), [ii, ee] = Cr(bt), Sr = (t) => {
  const {
    __scopeDialog: e,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: s,
    modal: a = !0
  } = t, i = u.useRef(null), l = u.useRef(null), [f, d] = ht({
    prop: r,
    defaultProp: o ?? !1,
    onChange: s,
    caller: bt
  });
  return /* @__PURE__ */ c.jsx(
    ii,
    {
      scope: e,
      triggerRef: i,
      contentRef: l,
      contentId: be(),
      titleId: be(),
      descriptionId: be(),
      open: f,
      onOpenChange: d,
      onOpenToggle: u.useCallback(() => d((p) => !p), [d]),
      modal: a,
      children: n
    }
  );
};
Sr.displayName = bt;
var _r = "DialogTrigger", Rr = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, o = ee(_r, n), s = G(e, o.triggerRef);
    return /* @__PURE__ */ c.jsx(
      B.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": cn(o.open),
        ...r,
        ref: s,
        onClick: P(t.onClick, o.onOpenToggle)
      }
    );
  }
);
Rr.displayName = _r;
var sn = "DialogPortal", [ci, Ar] = Cr(sn, {
  forceMount: void 0
}), Mr = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: o } = t, s = ee(sn, e);
  return /* @__PURE__ */ c.jsx(ci, { scope: e, forceMount: n, children: u.Children.map(r, (a) => /* @__PURE__ */ c.jsx(de, { present: n || s.open, children: /* @__PURE__ */ c.jsx(gt, { asChild: !0, container: o, children: a }) })) });
};
Mr.displayName = sn;
var ct = "DialogOverlay", Pr = u.forwardRef(
  (t, e) => {
    const n = Ar(ct, t.__scopeDialog), { forceMount: r = n.forceMount, ...o } = t, s = ee(ct, t.__scopeDialog);
    return s.modal ? /* @__PURE__ */ c.jsx(de, { present: r || s.open, children: /* @__PURE__ */ c.jsx(ui, { ...o, ref: e }) }) : null;
  }
);
Pr.displayName = ct;
var li = it("DialogOverlay.RemoveScroll"), ui = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, o = ee(ct, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ c.jsx(on, { as: li, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ c.jsx(
        B.div,
        {
          "data-state": cn(o.open),
          ...r,
          ref: e,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), we = "DialogContent", Or = u.forwardRef(
  (t, e) => {
    const n = Ar(we, t.__scopeDialog), { forceMount: r = n.forceMount, ...o } = t, s = ee(we, t.__scopeDialog);
    return /* @__PURE__ */ c.jsx(de, { present: r || s.open, children: s.modal ? /* @__PURE__ */ c.jsx(di, { ...o, ref: e }) : /* @__PURE__ */ c.jsx(fi, { ...o, ref: e }) });
  }
);
Or.displayName = we;
var di = u.forwardRef(
  (t, e) => {
    const n = ee(we, t.__scopeDialog), r = u.useRef(null), o = G(e, n.contentRef, r);
    return u.useEffect(() => {
      const s = r.current;
      if (s) return Er(s);
    }, []), /* @__PURE__ */ c.jsx(
      Nr,
      {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: P(t.onCloseAutoFocus, (s) => {
          s.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: P(t.onPointerDownOutside, (s) => {
          const a = s.detail.originalEvent, i = a.button === 0 && a.ctrlKey === !0;
          (a.button === 2 || i) && s.preventDefault();
        }),
        onFocusOutside: P(
          t.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), fi = u.forwardRef(
  (t, e) => {
    const n = ee(we, t.__scopeDialog), r = u.useRef(!1), o = u.useRef(!1);
    return /* @__PURE__ */ c.jsx(
      Nr,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          t.onCloseAutoFocus?.(s), s.defaultPrevented || (r.current || n.triggerRef.current?.focus(), s.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (s) => {
          t.onInteractOutside?.(s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const a = s.target;
          n.triggerRef.current?.contains(a) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && o.current && s.preventDefault();
        }
      }
    );
  }
), Nr = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: s, ...a } = t, i = ee(we, n), l = u.useRef(null), f = G(e, l);
    return pr(), /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
      /* @__PURE__ */ c.jsx(
        rn,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ c.jsx(
            vt,
            {
              role: "dialog",
              id: i.contentId,
              "aria-describedby": i.descriptionId,
              "aria-labelledby": i.titleId,
              "data-state": cn(i.open),
              ...a,
              ref: f,
              onDismiss: () => i.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
        /* @__PURE__ */ c.jsx(pi, { titleId: i.titleId }),
        /* @__PURE__ */ c.jsx(hi, { contentRef: l, descriptionId: i.descriptionId })
      ] })
    ] });
  }
), an = "DialogTitle", Tr = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, o = ee(an, n);
    return /* @__PURE__ */ c.jsx(B.h2, { id: o.titleId, ...r, ref: e });
  }
);
Tr.displayName = an;
var Dr = "DialogDescription", jr = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, o = ee(Dr, n);
    return /* @__PURE__ */ c.jsx(B.p, { id: o.descriptionId, ...r, ref: e });
  }
);
jr.displayName = Dr;
var Ir = "DialogClose", Lr = u.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, o = ee(Ir, n);
    return /* @__PURE__ */ c.jsx(
      B.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: P(t.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
Lr.displayName = Ir;
function cn(t) {
  return t ? "open" : "closed";
}
var kr = "DialogTitleWarning", [vf, Fr] = Os(kr, {
  contentName: we,
  titleName: an,
  docsSlug: "dialog"
}), pi = ({ titleId: t }) => {
  const e = Fr(kr), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return u.useEffect(() => {
    t && (document.getElementById(t) || console.error(n));
  }, [n, t]), null;
}, mi = "DialogDescriptionWarning", hi = ({ contentRef: t, descriptionId: e }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Fr(mi).contentName}}.`;
  return u.useEffect(() => {
    const o = t.current?.getAttribute("aria-describedby");
    e && o && (document.getElementById(e) || console.warn(r));
  }, [r, t, e]), null;
}, vi = Sr, gf = Rr, gi = Mr, xi = Pr, bi = Or, yi = Tr, wi = jr, Ei = Lr;
function Ci(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(vi, { "data-slot": "sheet", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function Si(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(gi, { "data-slot": "sheet-portal", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function _i(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(xi, { "data-slot": "sheet-overlay", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Ri(t) {
  const e = A.c(17);
  let n, r, o, s;
  e[0] !== t ? ({
    className: r,
    children: n,
    side: s,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s) : (n = e[1], r = e[2], o = e[3], s = e[4]);
  const a = s === void 0 ? "right" : s;
  let i;
  e[5] === Symbol.for("react.memo_cache_sentinel") ? (i = /* @__PURE__ */ c.jsx(_i, {}), e[5] = i) : i = e[5];
  const l = a === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", f = a === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", d = a === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", p = a === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t";
  let m;
  e[6] !== r || e[7] !== l || e[8] !== f || e[9] !== d || e[10] !== p ? (m = L("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500", l, f, d, p, r), e[6] = r, e[7] = l, e[8] = f, e[9] = d, e[10] = p, e[11] = m) : m = e[11];
  let h;
  e[12] === Symbol.for("react.memo_cache_sentinel") ? (h = /* @__PURE__ */ c.jsxs(Ei, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none", children: [
    /* @__PURE__ */ c.jsx(Js, { className: "size-4" }),
    /* @__PURE__ */ c.jsx("span", { className: "sr-only", children: "Close" })
  ] }), e[12] = h) : h = e[12];
  let g;
  return e[13] !== n || e[14] !== o || e[15] !== m ? (g = /* @__PURE__ */ c.jsxs(Si, { children: [
    i,
    /* @__PURE__ */ c.jsxs(bi, { "data-slot": "sheet-content", className: m, ...o, children: [
      n,
      h
    ] })
  ] }), e[13] = n, e[14] = o, e[15] = m, e[16] = g) : g = e[16], g;
}
function Ai(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("flex flex-col gap-1.5 p-4", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sheet-header", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Mi(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("text-foreground font-semibold", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(yi, { "data-slot": "sheet-title", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Pi(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("text-muted-foreground text-sm", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(wi, { "data-slot": "sheet-description", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
const Oi = ["top", "right", "bottom", "left"], pe = Math.min, z = Math.max, lt = Math.round, tt = Math.floor, oe = (t) => ({
  x: t,
  y: t
}), Ni = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Ti = {
  start: "end",
  end: "start"
};
function zt(t, e, n) {
  return z(t, pe(e, n));
}
function ce(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function le(t) {
  return t.split("-")[0];
}
function Te(t) {
  return t.split("-")[1];
}
function ln(t) {
  return t === "x" ? "y" : "x";
}
function un(t) {
  return t === "y" ? "height" : "width";
}
const Di = /* @__PURE__ */ new Set(["top", "bottom"]);
function re(t) {
  return Di.has(le(t)) ? "y" : "x";
}
function dn(t) {
  return ln(re(t));
}
function ji(t, e, n) {
  n === void 0 && (n = !1);
  const r = Te(t), o = dn(t), s = un(o);
  let a = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (a = ut(a)), [a, ut(a)];
}
function Ii(t) {
  const e = ut(t);
  return [Yt(t), e, Yt(e)];
}
function Yt(t) {
  return t.replace(/start|end/g, (e) => Ti[e]);
}
const Hn = ["left", "right"], Wn = ["right", "left"], Li = ["top", "bottom"], ki = ["bottom", "top"];
function Fi(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? Wn : Hn : e ? Hn : Wn;
    case "left":
    case "right":
      return e ? Li : ki;
    default:
      return [];
  }
}
function $i(t, e, n, r) {
  const o = Te(t);
  let s = Fi(le(t), n === "start", r);
  return o && (s = s.map((a) => a + "-" + o), e && (s = s.concat(s.map(Yt)))), s;
}
function ut(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Ni[e]);
}
function Bi(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function $r(t) {
  return typeof t != "number" ? Bi(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function dt(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: o
  } = t;
  return {
    width: r,
    height: o,
    top: n,
    left: e,
    right: e + r,
    bottom: n + o,
    x: e,
    y: n
  };
}
function Gn(t, e, n) {
  let {
    reference: r,
    floating: o
  } = t;
  const s = re(e), a = dn(e), i = un(a), l = le(e), f = s === "y", d = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, m = r[i] / 2 - o[i] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: d,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (Te(e)) {
    case "start":
      h[a] -= m * (n && f ? -1 : 1);
      break;
    case "end":
      h[a] += m * (n && f ? -1 : 1);
      break;
  }
  return h;
}
const Hi = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: s = [],
    platform: a
  } = n, i = s.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(e));
  let f = await a.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: d,
    y: p
  } = Gn(f, r, l), m = r, h = {}, g = 0;
  for (let v = 0; v < i.length; v++) {
    const {
      name: x,
      fn: b
    } = i[v], {
      x: y,
      y: w,
      data: E,
      reset: C
    } = await b({
      x: d,
      y: p,
      initialPlacement: r,
      placement: m,
      strategy: o,
      middlewareData: h,
      rects: f,
      platform: a,
      elements: {
        reference: t,
        floating: e
      }
    });
    d = y ?? d, p = w ?? p, h = {
      ...h,
      [x]: {
        ...h[x],
        ...E
      }
    }, C && g <= 50 && (g++, typeof C == "object" && (C.placement && (m = C.placement), C.rects && (f = C.rects === !0 ? await a.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : C.rects), {
      x: d,
      y: p
    } = Gn(f, m, l)), v = -1);
  }
  return {
    x: d,
    y: p,
    placement: m,
    strategy: o,
    middlewareData: h
  };
};
async function $e(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: s,
    rects: a,
    elements: i,
    strategy: l
  } = t, {
    boundary: f = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: p = "floating",
    altBoundary: m = !1,
    padding: h = 0
  } = ce(e, t), g = $r(h), x = i[m ? p === "floating" ? "reference" : "floating" : p], b = dt(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(x))) == null || n ? x : x.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(i.floating)),
    boundary: f,
    rootBoundary: d,
    strategy: l
  })), y = p === "floating" ? {
    x: r,
    y: o,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, w = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i.floating)), E = await (s.isElement == null ? void 0 : s.isElement(w)) ? await (s.getScale == null ? void 0 : s.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = dt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: y,
    offsetParent: w,
    strategy: l
  }) : y);
  return {
    top: (b.top - C.top + g.top) / E.y,
    bottom: (C.bottom - b.bottom + g.bottom) / E.y,
    left: (b.left - C.left + g.left) / E.x,
    right: (C.right - b.right + g.right) / E.x
  };
}
const Wi = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: s,
      platform: a,
      elements: i,
      middlewareData: l
    } = e, {
      element: f,
      padding: d = 0
    } = ce(t, e) || {};
    if (f == null)
      return {};
    const p = $r(d), m = {
      x: n,
      y: r
    }, h = dn(o), g = un(h), v = await a.getDimensions(f), x = h === "y", b = x ? "top" : "left", y = x ? "bottom" : "right", w = x ? "clientHeight" : "clientWidth", E = s.reference[g] + s.reference[h] - m[h] - s.floating[g], C = m[h] - s.reference[h], _ = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(f));
    let S = _ ? _[w] : 0;
    (!S || !await (a.isElement == null ? void 0 : a.isElement(_))) && (S = i.floating[w] || s.floating[g]);
    const M = E / 2 - C / 2, O = S / 2 - v[g] / 2 - 1, N = pe(p[b], O), D = pe(p[y], O), j = N, I = S - v[g] - D, k = S / 2 - v[g] / 2 + M, $ = zt(j, k, I), F = !l.arrow && Te(o) != null && k !== $ && s.reference[g] / 2 - (k < j ? N : D) - v[g] / 2 < 0, H = F ? k < j ? k - j : k - I : 0;
    return {
      [h]: m[h] + H,
      data: {
        [h]: $,
        centerOffset: k - $ - H,
        ...F && {
          alignmentOffset: H
        }
      },
      reset: F
    };
  }
}), Gi = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        middlewareData: s,
        rects: a,
        initialPlacement: i,
        platform: l,
        elements: f
      } = e, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: m,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: v = !0,
        ...x
      } = ce(t, e);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const b = le(o), y = re(i), w = le(i) === i, E = await (l.isRTL == null ? void 0 : l.isRTL(f.floating)), C = m || (w || !v ? [ut(i)] : Ii(i)), _ = g !== "none";
      !m && _ && C.push(...$i(i, v, g, E));
      const S = [i, ...C], M = await $e(e, x), O = [];
      let N = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (d && O.push(M[b]), p) {
        const k = ji(o, a, E);
        O.push(M[k[0]], M[k[1]]);
      }
      if (N = [...N, {
        placement: o,
        overflows: O
      }], !O.every((k) => k <= 0)) {
        var D, j;
        const k = (((D = s.flip) == null ? void 0 : D.index) || 0) + 1, $ = S[k];
        if ($ && (!(p === "alignment" ? y !== re($) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        N.every((T) => re(T.placement) === y ? T.overflows[0] > 0 : !0)))
          return {
            data: {
              index: k,
              overflows: N
            },
            reset: {
              placement: $
            }
          };
        let F = (j = N.filter((H) => H.overflows[0] <= 0).sort((H, T) => H.overflows[1] - T.overflows[1])[0]) == null ? void 0 : j.placement;
        if (!F)
          switch (h) {
            case "bestFit": {
              var I;
              const H = (I = N.filter((T) => {
                if (_) {
                  const R = re(T.placement);
                  return R === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  R === "y";
                }
                return !0;
              }).map((T) => [T.placement, T.overflows.filter((R) => R > 0).reduce((R, K) => R + K, 0)]).sort((T, R) => T[1] - R[1])[0]) == null ? void 0 : I[0];
              H && (F = H);
              break;
            }
            case "initialPlacement":
              F = i;
              break;
          }
        if (o !== F)
          return {
            reset: {
              placement: F
            }
          };
      }
      return {};
    }
  };
};
function Kn(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function Un(t) {
  return Oi.some((e) => t[e] >= 0);
}
const Ki = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...o
      } = ce(t, e);
      switch (r) {
        case "referenceHidden": {
          const s = await $e(e, {
            ...o,
            elementContext: "reference"
          }), a = Kn(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: Un(a)
            }
          };
        }
        case "escaped": {
          const s = await $e(e, {
            ...o,
            altBoundary: !0
          }), a = Kn(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: Un(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, Br = /* @__PURE__ */ new Set(["left", "top"]);
async function Ui(t, e) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), a = le(n), i = Te(n), l = re(n) === "y", f = Br.has(a) ? -1 : 1, d = s && l ? -1 : 1, p = ce(e, t);
  let {
    mainAxis: m,
    crossAxis: h,
    alignmentAxis: g
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return i && typeof g == "number" && (h = i === "end" ? g * -1 : g), l ? {
    x: h * d,
    y: m * f
  } : {
    x: m * f,
    y: h * d
  };
}
const Vi = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: o,
        y: s,
        placement: a,
        middlewareData: i
      } = e, l = await Ui(e, t);
      return a === ((n = i.offset) == null ? void 0 : n.placement) && (r = i.arrow) != null && r.alignmentOffset ? {} : {
        x: o + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, zi = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: o
      } = e, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: i = {
          fn: (x) => {
            let {
              x: b,
              y
            } = x;
            return {
              x: b,
              y
            };
          }
        },
        ...l
      } = ce(t, e), f = {
        x: n,
        y: r
      }, d = await $e(e, l), p = re(le(o)), m = ln(p);
      let h = f[m], g = f[p];
      if (s) {
        const x = m === "y" ? "top" : "left", b = m === "y" ? "bottom" : "right", y = h + d[x], w = h - d[b];
        h = zt(y, h, w);
      }
      if (a) {
        const x = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", y = g + d[x], w = g - d[b];
        g = zt(y, g, w);
      }
      const v = i.fn({
        ...e,
        [m]: h,
        [p]: g
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [m]: s,
            [p]: a
          }
        }
      };
    }
  };
}, Yi = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: s,
        middlewareData: a
      } = e, {
        offset: i = 0,
        mainAxis: l = !0,
        crossAxis: f = !0
      } = ce(t, e), d = {
        x: n,
        y: r
      }, p = re(o), m = ln(p);
      let h = d[m], g = d[p];
      const v = ce(i, e), x = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (l) {
        const w = m === "y" ? "height" : "width", E = s.reference[m] - s.floating[w] + x.mainAxis, C = s.reference[m] + s.reference[w] - x.mainAxis;
        h < E ? h = E : h > C && (h = C);
      }
      if (f) {
        var b, y;
        const w = m === "y" ? "width" : "height", E = Br.has(le(o)), C = s.reference[p] - s.floating[w] + (E && ((b = a.offset) == null ? void 0 : b[p]) || 0) + (E ? 0 : x.crossAxis), _ = s.reference[p] + s.reference[w] + (E ? 0 : ((y = a.offset) == null ? void 0 : y[p]) || 0) - (E ? x.crossAxis : 0);
        g < C ? g = C : g > _ && (g = _);
      }
      return {
        [m]: h,
        [p]: g
      };
    }
  };
}, qi = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        rects: s,
        platform: a,
        elements: i
      } = e, {
        apply: l = () => {
        },
        ...f
      } = ce(t, e), d = await $e(e, f), p = le(o), m = Te(o), h = re(o) === "y", {
        width: g,
        height: v
      } = s.floating;
      let x, b;
      p === "top" || p === "bottom" ? (x = p, b = m === (await (a.isRTL == null ? void 0 : a.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (b = p, x = m === "end" ? "top" : "bottom");
      const y = v - d.top - d.bottom, w = g - d.left - d.right, E = pe(v - d[x], y), C = pe(g - d[b], w), _ = !e.middlewareData.shift;
      let S = E, M = C;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (M = w), (r = e.middlewareData.shift) != null && r.enabled.y && (S = y), _ && !m) {
        const N = z(d.left, 0), D = z(d.right, 0), j = z(d.top, 0), I = z(d.bottom, 0);
        h ? M = g - 2 * (N !== 0 || D !== 0 ? N + D : z(d.left, d.right)) : S = v - 2 * (j !== 0 || I !== 0 ? j + I : z(d.top, d.bottom));
      }
      await l({
        ...e,
        availableWidth: M,
        availableHeight: S
      });
      const O = await a.getDimensions(i.floating);
      return g !== O.width || v !== O.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function yt() {
  return typeof window < "u";
}
function De(t) {
  return Hr(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Y(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ie(t) {
  var e;
  return (e = (Hr(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Hr(t) {
  return yt() ? t instanceof Node || t instanceof Y(t).Node : !1;
}
function X(t) {
  return yt() ? t instanceof Element || t instanceof Y(t).Element : !1;
}
function ae(t) {
  return yt() ? t instanceof HTMLElement || t instanceof Y(t).HTMLElement : !1;
}
function Vn(t) {
  return !yt() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Y(t).ShadowRoot;
}
const Xi = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ke(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: o
  } = Q(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !Xi.has(o);
}
const Qi = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Zi(t) {
  return Qi.has(De(t));
}
const Ji = [":popover-open", ":modal"];
function wt(t) {
  return Ji.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const ec = ["transform", "translate", "scale", "rotate", "perspective"], tc = ["transform", "translate", "scale", "rotate", "perspective", "filter"], nc = ["paint", "layout", "strict", "content"];
function fn(t) {
  const e = pn(), n = X(t) ? Q(t) : t;
  return ec.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || tc.some((r) => (n.willChange || "").includes(r)) || nc.some((r) => (n.contain || "").includes(r));
}
function rc(t) {
  let e = me(t);
  for (; ae(e) && !Oe(e); ) {
    if (fn(e))
      return e;
    if (wt(e))
      return null;
    e = me(e);
  }
  return null;
}
function pn() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const oc = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Oe(t) {
  return oc.has(De(t));
}
function Q(t) {
  return Y(t).getComputedStyle(t);
}
function Et(t) {
  return X(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function me(t) {
  if (De(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Vn(t) && t.host || // Fallback.
    ie(t)
  );
  return Vn(e) ? e.host : e;
}
function Wr(t) {
  const e = me(t);
  return Oe(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ae(e) && Ke(e) ? e : Wr(e);
}
function Be(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const o = Wr(t), s = o === ((r = t.ownerDocument) == null ? void 0 : r.body), a = Y(o);
  if (s) {
    const i = qt(a);
    return e.concat(a, a.visualViewport || [], Ke(o) ? o : [], i && n ? Be(i) : []);
  }
  return e.concat(o, Be(o, [], n));
}
function qt(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Gr(t) {
  const e = Q(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const o = ae(t), s = o ? t.offsetWidth : n, a = o ? t.offsetHeight : r, i = lt(n) !== s || lt(r) !== a;
  return i && (n = s, r = a), {
    width: n,
    height: r,
    $: i
  };
}
function mn(t) {
  return X(t) ? t : t.contextElement;
}
function Pe(t) {
  const e = mn(t);
  if (!ae(e))
    return oe(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: o,
    $: s
  } = Gr(e);
  let a = (s ? lt(n.width) : n.width) / r, i = (s ? lt(n.height) : n.height) / o;
  return (!a || !Number.isFinite(a)) && (a = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: a,
    y: i
  };
}
const sc = /* @__PURE__ */ oe(0);
function Kr(t) {
  const e = Y(t);
  return !pn() || !e.visualViewport ? sc : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ac(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Y(t) ? !1 : e;
}
function Ee(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), s = mn(t);
  let a = oe(1);
  e && (r ? X(r) && (a = Pe(r)) : a = Pe(t));
  const i = ac(s, n, r) ? Kr(s) : oe(0);
  let l = (o.left + i.x) / a.x, f = (o.top + i.y) / a.y, d = o.width / a.x, p = o.height / a.y;
  if (s) {
    const m = Y(s), h = r && X(r) ? Y(r) : r;
    let g = m, v = qt(g);
    for (; v && r && h !== g; ) {
      const x = Pe(v), b = v.getBoundingClientRect(), y = Q(v), w = b.left + (v.clientLeft + parseFloat(y.paddingLeft)) * x.x, E = b.top + (v.clientTop + parseFloat(y.paddingTop)) * x.y;
      l *= x.x, f *= x.y, d *= x.x, p *= x.y, l += w, f += E, g = Y(v), v = qt(g);
    }
  }
  return dt({
    width: d,
    height: p,
    x: l,
    y: f
  });
}
function hn(t, e) {
  const n = Et(t).scrollLeft;
  return e ? e.left + n : Ee(ie(t)).left + n;
}
function Ur(t, e, n) {
  n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), o = r.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    hn(t, r)
  )), s = r.top + e.scrollTop;
  return {
    x: o,
    y: s
  };
}
function ic(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: o
  } = t;
  const s = o === "fixed", a = ie(r), i = e ? wt(e.floating) : !1;
  if (r === a || i && s)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = oe(1);
  const d = oe(0), p = ae(r);
  if ((p || !p && !s) && ((De(r) !== "body" || Ke(a)) && (l = Et(r)), ae(r))) {
    const h = Ee(r);
    f = Pe(r), d.x = h.x + r.clientLeft, d.y = h.y + r.clientTop;
  }
  const m = a && !p && !s ? Ur(a, l, !0) : oe(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - l.scrollLeft * f.x + d.x + m.x,
    y: n.y * f.y - l.scrollTop * f.y + d.y + m.y
  };
}
function cc(t) {
  return Array.from(t.getClientRects());
}
function lc(t) {
  const e = ie(t), n = Et(t), r = t.ownerDocument.body, o = z(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = z(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + hn(t);
  const i = -n.scrollTop;
  return Q(r).direction === "rtl" && (a += z(e.clientWidth, r.clientWidth) - o), {
    width: o,
    height: s,
    x: a,
    y: i
  };
}
function uc(t, e) {
  const n = Y(t), r = ie(t), o = n.visualViewport;
  let s = r.clientWidth, a = r.clientHeight, i = 0, l = 0;
  if (o) {
    s = o.width, a = o.height;
    const f = pn();
    (!f || f && e === "fixed") && (i = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: s,
    height: a,
    x: i,
    y: l
  };
}
const dc = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function fc(t, e) {
  const n = Ee(t, !0, e === "fixed"), r = n.top + t.clientTop, o = n.left + t.clientLeft, s = ae(t) ? Pe(t) : oe(1), a = t.clientWidth * s.x, i = t.clientHeight * s.y, l = o * s.x, f = r * s.y;
  return {
    width: a,
    height: i,
    x: l,
    y: f
  };
}
function zn(t, e, n) {
  let r;
  if (e === "viewport")
    r = uc(t, n);
  else if (e === "document")
    r = lc(ie(t));
  else if (X(e))
    r = fc(e, n);
  else {
    const o = Kr(t);
    r = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return dt(r);
}
function Vr(t, e) {
  const n = me(t);
  return n === e || !X(n) || Oe(n) ? !1 : Q(n).position === "fixed" || Vr(n, e);
}
function pc(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = Be(t, [], !1).filter((i) => X(i) && De(i) !== "body"), o = null;
  const s = Q(t).position === "fixed";
  let a = s ? me(t) : t;
  for (; X(a) && !Oe(a); ) {
    const i = Q(a), l = fn(a);
    !l && i.position === "fixed" && (o = null), (s ? !l && !o : !l && i.position === "static" && !!o && dc.has(o.position) || Ke(a) && !l && Vr(t, a)) ? r = r.filter((d) => d !== a) : o = i, a = me(a);
  }
  return e.set(t, r), r;
}
function mc(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = t;
  const a = [...n === "clippingAncestors" ? wt(e) ? [] : pc(e, this._c) : [].concat(n), r], i = a[0], l = a.reduce((f, d) => {
    const p = zn(e, d, o);
    return f.top = z(p.top, f.top), f.right = pe(p.right, f.right), f.bottom = pe(p.bottom, f.bottom), f.left = z(p.left, f.left), f;
  }, zn(e, i, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function hc(t) {
  const {
    width: e,
    height: n
  } = Gr(t);
  return {
    width: e,
    height: n
  };
}
function vc(t, e, n) {
  const r = ae(e), o = ie(e), s = n === "fixed", a = Ee(t, !0, s, e);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = oe(0);
  function f() {
    l.x = hn(o);
  }
  if (r || !r && !s)
    if ((De(e) !== "body" || Ke(o)) && (i = Et(e)), r) {
      const h = Ee(e, !0, s, e);
      l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop;
    } else o && f();
  s && !r && o && f();
  const d = o && !r && !s ? Ur(o, i) : oe(0), p = a.left + i.scrollLeft - l.x - d.x, m = a.top + i.scrollTop - l.y - d.y;
  return {
    x: p,
    y: m,
    width: a.width,
    height: a.height
  };
}
function Bt(t) {
  return Q(t).position === "static";
}
function Yn(t, e) {
  if (!ae(t) || Q(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return ie(t) === n && (n = n.ownerDocument.body), n;
}
function zr(t, e) {
  const n = Y(t);
  if (wt(t))
    return n;
  if (!ae(t)) {
    let o = me(t);
    for (; o && !Oe(o); ) {
      if (X(o) && !Bt(o))
        return o;
      o = me(o);
    }
    return n;
  }
  let r = Yn(t, e);
  for (; r && Zi(r) && Bt(r); )
    r = Yn(r, e);
  return r && Oe(r) && Bt(r) && !fn(r) ? n : r || rc(t) || n;
}
const gc = async function(t) {
  const e = this.getOffsetParent || zr, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: vc(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function xc(t) {
  return Q(t).direction === "rtl";
}
const bc = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ic,
  getDocumentElement: ie,
  getClippingRect: mc,
  getOffsetParent: zr,
  getElementRects: gc,
  getClientRects: cc,
  getDimensions: hc,
  getScale: Pe,
  isElement: X,
  isRTL: xc
};
function Yr(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function yc(t, e) {
  let n = null, r;
  const o = ie(t);
  function s() {
    var i;
    clearTimeout(r), (i = n) == null || i.disconnect(), n = null;
  }
  function a(i, l) {
    i === void 0 && (i = !1), l === void 0 && (l = 1), s();
    const f = t.getBoundingClientRect(), {
      left: d,
      top: p,
      width: m,
      height: h
    } = f;
    if (i || e(), !m || !h)
      return;
    const g = tt(p), v = tt(o.clientWidth - (d + m)), x = tt(o.clientHeight - (p + h)), b = tt(d), w = {
      rootMargin: -g + "px " + -v + "px " + -x + "px " + -b + "px",
      threshold: z(0, pe(1, l)) || 1
    };
    let E = !0;
    function C(_) {
      const S = _[0].intersectionRatio;
      if (S !== l) {
        if (!E)
          return a();
        S ? a(!1, S) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      S === 1 && !Yr(f, t.getBoundingClientRect()) && a(), E = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...w,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, w);
    }
    n.observe(t);
  }
  return a(!0), s;
}
function wc(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: s = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, f = mn(t), d = o || s ? [...f ? Be(f) : [], ...Be(e)] : [];
  d.forEach((b) => {
    o && b.addEventListener("scroll", n, {
      passive: !0
    }), s && b.addEventListener("resize", n);
  });
  const p = f && i ? yc(f, n) : null;
  let m = -1, h = null;
  a && (h = new ResizeObserver((b) => {
    let [y] = b;
    y && y.target === f && h && (h.unobserve(e), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var w;
      (w = h) == null || w.observe(e);
    })), n();
  }), f && !l && h.observe(f), h.observe(e));
  let g, v = l ? Ee(t) : null;
  l && x();
  function x() {
    const b = Ee(t);
    v && !Yr(v, b) && n(), v = b, g = requestAnimationFrame(x);
  }
  return n(), () => {
    var b;
    d.forEach((y) => {
      o && y.removeEventListener("scroll", n), s && y.removeEventListener("resize", n);
    }), p?.(), (b = h) == null || b.disconnect(), h = null, l && cancelAnimationFrame(g);
  };
}
const Ec = Vi, Cc = zi, Sc = Gi, _c = qi, Rc = Ki, qn = Wi, Ac = Yi, Mc = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: bc,
    ...n
  }, s = {
    ...o.platform,
    _c: r
  };
  return Hi(t, e, {
    ...o,
    platform: s
  });
};
var Pc = typeof document < "u", Oc = function() {
}, at = Pc ? u.useLayoutEffect : Oc;
function ft(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, o;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!ft(t[r], e[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(t), n = o.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = o[r];
      if (!(s === "_owner" && t.$$typeof) && !ft(t[s], e[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function qr(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Xn(t, e) {
  const n = qr(t);
  return Math.round(e * n) / n;
}
function Ht(t) {
  const e = u.useRef(t);
  return at(() => {
    e.current = t;
  }), e;
}
function Nc(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: s,
      floating: a
    } = {},
    transform: i = !0,
    whileElementsMounted: l,
    open: f
  } = t, [d, p] = u.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [m, h] = u.useState(r);
  ft(m, r) || h(r);
  const [g, v] = u.useState(null), [x, b] = u.useState(null), y = u.useCallback((T) => {
    T !== _.current && (_.current = T, v(T));
  }, []), w = u.useCallback((T) => {
    T !== S.current && (S.current = T, b(T));
  }, []), E = s || g, C = a || x, _ = u.useRef(null), S = u.useRef(null), M = u.useRef(d), O = l != null, N = Ht(l), D = Ht(o), j = Ht(f), I = u.useCallback(() => {
    if (!_.current || !S.current)
      return;
    const T = {
      placement: e,
      strategy: n,
      middleware: m
    };
    D.current && (T.platform = D.current), Mc(_.current, S.current, T).then((R) => {
      const K = {
        ...R,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: j.current !== !1
      };
      k.current && !ft(M.current, K) && (M.current = K, Ds.flushSync(() => {
        p(K);
      }));
    });
  }, [m, e, n, D, j]);
  at(() => {
    f === !1 && M.current.isPositioned && (M.current.isPositioned = !1, p((T) => ({
      ...T,
      isPositioned: !1
    })));
  }, [f]);
  const k = u.useRef(!1);
  at(() => (k.current = !0, () => {
    k.current = !1;
  }), []), at(() => {
    if (E && (_.current = E), C && (S.current = C), E && C) {
      if (N.current)
        return N.current(E, C, I);
      I();
    }
  }, [E, C, I, N, O]);
  const $ = u.useMemo(() => ({
    reference: _,
    floating: S,
    setReference: y,
    setFloating: w
  }), [y, w]), F = u.useMemo(() => ({
    reference: E,
    floating: C
  }), [E, C]), H = u.useMemo(() => {
    const T = {
      position: n,
      left: 0,
      top: 0
    };
    if (!F.floating)
      return T;
    const R = Xn(F.floating, d.x), K = Xn(F.floating, d.y);
    return i ? {
      ...T,
      transform: "translate(" + R + "px, " + K + "px)",
      ...qr(F.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: R,
      top: K
    };
  }, [n, i, F.floating, d.x, d.y]);
  return u.useMemo(() => ({
    ...d,
    update: I,
    refs: $,
    elements: F,
    floatingStyles: H
  }), [d, I, $, F, H]);
}
const Tc = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? qn({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? qn({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, Dc = (t, e) => ({
  ...Ec(t),
  options: [t, e]
}), jc = (t, e) => ({
  ...Cc(t),
  options: [t, e]
}), Ic = (t, e) => ({
  ...Ac(t),
  options: [t, e]
}), Lc = (t, e) => ({
  ...Sc(t),
  options: [t, e]
}), kc = (t, e) => ({
  ..._c(t),
  options: [t, e]
}), Fc = (t, e) => ({
  ...Rc(t),
  options: [t, e]
}), $c = (t, e) => ({
  ...Tc(t),
  options: [t, e]
});
var Bc = "Arrow", Xr = u.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: o = 5, ...s } = t;
  return /* @__PURE__ */ c.jsx(
    B.svg,
    {
      ...s,
      ref: e,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ c.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Xr.displayName = Bc;
var Hc = Xr, vn = "Popper", [Qr, Ct] = he(vn), [Wc, Zr] = Qr(vn), Jr = (t) => {
  const { __scopePopper: e, children: n } = t, [r, o] = u.useState(null);
  return /* @__PURE__ */ c.jsx(Wc, { scope: e, anchor: r, onAnchorChange: o, children: n });
};
Jr.displayName = vn;
var eo = "PopperAnchor", to = u.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...o } = t, s = Zr(eo, n), a = u.useRef(null), i = G(e, a), l = u.useRef(null);
    return u.useEffect(() => {
      const f = l.current;
      l.current = r?.current || a.current, f !== l.current && s.onAnchorChange(l.current);
    }), r ? null : /* @__PURE__ */ c.jsx(B.div, { ...o, ref: i });
  }
);
to.displayName = eo;
var gn = "PopperContent", [Gc, Kc] = Qr(gn), no = u.forwardRef(
  (t, e) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: s = "center",
      alignOffset: a = 0,
      arrowPadding: i = 0,
      avoidCollisions: l = !0,
      collisionBoundary: f = [],
      collisionPadding: d = 0,
      sticky: p = "partial",
      hideWhenDetached: m = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: g,
      ...v
    } = t, x = Zr(gn, n), [b, y] = u.useState(null), w = G(e, (W) => y(W)), [E, C] = u.useState(null), _ = Ns(E), S = _?.width ?? 0, M = _?.height ?? 0, O = r + (s !== "center" ? "-" + s : ""), N = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, D = Array.isArray(f) ? f : [f], j = D.length > 0, I = {
      padding: N,
      boundary: D.filter(Vc),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: j
    }, { refs: k, floatingStyles: $, placement: F, isPositioned: H, middlewareData: T } = Nc({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: O,
      whileElementsMounted: (...W) => wc(...W, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: x.anchor
      },
      middleware: [
        Dc({ mainAxis: o + M, alignmentAxis: a }),
        l && jc({
          mainAxis: !0,
          crossAxis: !1,
          limiter: p === "partial" ? Ic() : void 0,
          ...I
        }),
        l && Lc({ ...I }),
        kc({
          ...I,
          apply: ({ elements: W, rects: Le, availableWidth: ws, availableHeight: Es }) => {
            const { width: Cs, height: Ss } = Le.reference, Xe = W.floating.style;
            Xe.setProperty("--radix-popper-available-width", `${ws}px`), Xe.setProperty("--radix-popper-available-height", `${Es}px`), Xe.setProperty("--radix-popper-anchor-width", `${Cs}px`), Xe.setProperty("--radix-popper-anchor-height", `${Ss}px`);
          }
        }),
        E && $c({ element: E, padding: i }),
        zc({ arrowWidth: S, arrowHeight: M }),
        m && Fc({ strategy: "referenceHidden", ...I })
      ]
    }), [R, K] = so(F), te = se(g);
    ye(() => {
      H && te?.();
    }, [H, te]);
    const ve = T.arrow?.x, je = T.arrow?.y, Ie = T.arrow?.centerOffset !== 0, [qe, ge] = u.useState();
    return ye(() => {
      b && ge(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ c.jsx(
      "div",
      {
        ref: k.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...$,
          transform: H ? $.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: qe,
          "--radix-popper-transform-origin": [
            T.transformOrigin?.x,
            T.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...T.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ c.jsx(
          Gc,
          {
            scope: n,
            placedSide: R,
            onArrowChange: C,
            arrowX: ve,
            arrowY: je,
            shouldHideArrow: Ie,
            children: /* @__PURE__ */ c.jsx(
              B.div,
              {
                "data-side": R,
                "data-align": K,
                ...v,
                ref: w,
                style: {
                  ...v.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: H ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
no.displayName = gn;
var ro = "PopperArrow", Uc = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, oo = u.forwardRef(function(e, n) {
  const { __scopePopper: r, ...o } = e, s = Kc(ro, r), a = Uc[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ c.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [a]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ c.jsx(
          Hc,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
oo.displayName = ro;
function Vc(t) {
  return t !== null;
}
var zc = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    const { placement: n, rects: r, middlewareData: o } = e, a = o.arrow?.centerOffset !== 0, i = a ? 0 : t.arrowWidth, l = a ? 0 : t.arrowHeight, [f, d] = so(n), p = { start: "0%", center: "50%", end: "100%" }[d], m = (o.arrow?.x ?? 0) + i / 2, h = (o.arrow?.y ?? 0) + l / 2;
    let g = "", v = "";
    return f === "bottom" ? (g = a ? p : `${m}px`, v = `${-l}px`) : f === "top" ? (g = a ? p : `${m}px`, v = `${r.floating.height + l}px`) : f === "right" ? (g = `${-l}px`, v = a ? p : `${h}px`) : f === "left" && (g = `${r.floating.width + l}px`, v = a ? p : `${h}px`), { data: { x: g, y: v } };
  }
});
function so(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var ao = Jr, io = to, co = no, lo = oo, Yc = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), qc = "VisuallyHidden", uo = u.forwardRef(
  (t, e) => /* @__PURE__ */ c.jsx(
    B.span,
    {
      ...t,
      ref: e,
      style: { ...Yc, ...t.style }
    }
  )
);
uo.displayName = qc;
var Xc = uo, [St, xf] = he("Tooltip", [
  Ct
]), _t = Ct(), fo = "TooltipProvider", Qc = 700, Xt = "tooltip.open", [Zc, xn] = St(fo), po = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = Qc,
    skipDelayDuration: r = 300,
    disableHoverableContent: o = !1,
    children: s
  } = t, a = u.useRef(!0), i = u.useRef(!1), l = u.useRef(0);
  return u.useEffect(() => {
    const f = l.current;
    return () => window.clearTimeout(f);
  }, []), /* @__PURE__ */ c.jsx(
    Zc,
    {
      scope: e,
      isOpenDelayedRef: a,
      delayDuration: n,
      onOpen: u.useCallback(() => {
        window.clearTimeout(l.current), a.current = !1;
      }, []),
      onClose: u.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(
          () => a.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: i,
      onPointerInTransitChange: u.useCallback((f) => {
        i.current = f;
      }, []),
      disableHoverableContent: o,
      children: s
    }
  );
};
po.displayName = fo;
var He = "Tooltip", [Jc, Ue] = St(He), mo = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: s,
    disableHoverableContent: a,
    delayDuration: i
  } = t, l = xn(He, t.__scopeTooltip), f = _t(e), [d, p] = u.useState(null), m = be(), h = u.useRef(0), g = a ?? l.disableHoverableContent, v = i ?? l.delayDuration, x = u.useRef(!1), [b, y] = ht({
    prop: r,
    defaultProp: o ?? !1,
    onChange: (S) => {
      S ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Xt))) : l.onClose(), s?.(S);
    },
    caller: He
  }), w = u.useMemo(() => b ? x.current ? "delayed-open" : "instant-open" : "closed", [b]), E = u.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, x.current = !1, y(!0);
  }, [y]), C = u.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, y(!1);
  }, [y]), _ = u.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      x.current = !0, y(!0), h.current = 0;
    }, v);
  }, [v, y]);
  return u.useEffect(() => () => {
    h.current && (window.clearTimeout(h.current), h.current = 0);
  }, []), /* @__PURE__ */ c.jsx(ao, { ...f, children: /* @__PURE__ */ c.jsx(
    Jc,
    {
      scope: e,
      contentId: m,
      open: b,
      stateAttribute: w,
      trigger: d,
      onTriggerChange: p,
      onTriggerEnter: u.useCallback(() => {
        l.isOpenDelayedRef.current ? _() : E();
      }, [l.isOpenDelayedRef, _, E]),
      onTriggerLeave: u.useCallback(() => {
        g ? C() : (window.clearTimeout(h.current), h.current = 0);
      }, [C, g]),
      onOpen: E,
      onClose: C,
      disableHoverableContent: g,
      children: n
    }
  ) });
};
mo.displayName = He;
var Qt = "TooltipTrigger", ho = u.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, o = Ue(Qt, n), s = xn(Qt, n), a = _t(n), i = u.useRef(null), l = G(e, i, o.onTriggerChange), f = u.useRef(!1), d = u.useRef(!1), p = u.useCallback(() => f.current = !1, []);
    return u.useEffect(() => () => document.removeEventListener("pointerup", p), [p]), /* @__PURE__ */ c.jsx(io, { asChild: !0, ...a, children: /* @__PURE__ */ c.jsx(
      B.button,
      {
        "aria-describedby": o.open ? o.contentId : void 0,
        "data-state": o.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: P(t.onPointerMove, (m) => {
          m.pointerType !== "touch" && !d.current && !s.isPointerInTransitRef.current && (o.onTriggerEnter(), d.current = !0);
        }),
        onPointerLeave: P(t.onPointerLeave, () => {
          o.onTriggerLeave(), d.current = !1;
        }),
        onPointerDown: P(t.onPointerDown, () => {
          o.open && o.onClose(), f.current = !0, document.addEventListener("pointerup", p, { once: !0 });
        }),
        onFocus: P(t.onFocus, () => {
          f.current || o.onOpen();
        }),
        onBlur: P(t.onBlur, o.onClose),
        onClick: P(t.onClick, o.onClose)
      }
    ) });
  }
);
ho.displayName = Qt;
var bn = "TooltipPortal", [el, tl] = St(bn, {
  forceMount: void 0
}), vo = (t) => {
  const { __scopeTooltip: e, forceMount: n, children: r, container: o } = t, s = Ue(bn, e);
  return /* @__PURE__ */ c.jsx(el, { scope: e, forceMount: n, children: /* @__PURE__ */ c.jsx(de, { present: n || s.open, children: /* @__PURE__ */ c.jsx(gt, { asChild: !0, container: o, children: r }) }) });
};
vo.displayName = bn;
var Ne = "TooltipContent", go = u.forwardRef(
  (t, e) => {
    const n = tl(Ne, t.__scopeTooltip), { forceMount: r = n.forceMount, side: o = "top", ...s } = t, a = Ue(Ne, t.__scopeTooltip);
    return /* @__PURE__ */ c.jsx(de, { present: r || a.open, children: a.disableHoverableContent ? /* @__PURE__ */ c.jsx(xo, { side: o, ...s, ref: e }) : /* @__PURE__ */ c.jsx(nl, { side: o, ...s, ref: e }) });
  }
), nl = u.forwardRef((t, e) => {
  const n = Ue(Ne, t.__scopeTooltip), r = xn(Ne, t.__scopeTooltip), o = u.useRef(null), s = G(e, o), [a, i] = u.useState(null), { trigger: l, onClose: f } = n, d = o.current, { onPointerInTransitChange: p } = r, m = u.useCallback(() => {
    i(null), p(!1);
  }, [p]), h = u.useCallback(
    (g, v) => {
      const x = g.currentTarget, b = { x: g.clientX, y: g.clientY }, y = al(b, x.getBoundingClientRect()), w = il(b, y), E = cl(v.getBoundingClientRect()), C = ul([...w, ...E]);
      i(C), p(!0);
    },
    [p]
  );
  return u.useEffect(() => () => m(), [m]), u.useEffect(() => {
    if (l && d) {
      const g = (x) => h(x, d), v = (x) => h(x, l);
      return l.addEventListener("pointerleave", g), d.addEventListener("pointerleave", v), () => {
        l.removeEventListener("pointerleave", g), d.removeEventListener("pointerleave", v);
      };
    }
  }, [l, d, h, m]), u.useEffect(() => {
    if (a) {
      const g = (v) => {
        const x = v.target, b = { x: v.clientX, y: v.clientY }, y = l?.contains(x) || d?.contains(x), w = !ll(b, a);
        y ? m() : w && (m(), f());
      };
      return document.addEventListener("pointermove", g), () => document.removeEventListener("pointermove", g);
    }
  }, [l, d, a, f, m]), /* @__PURE__ */ c.jsx(xo, { ...t, ref: s });
}), [rl, ol] = St(He, { isInside: !1 }), sl = Rs("TooltipContent"), xo = u.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": o,
      onEscapeKeyDown: s,
      onPointerDownOutside: a,
      ...i
    } = t, l = Ue(Ne, n), f = _t(n), { onClose: d } = l;
    return u.useEffect(() => (document.addEventListener(Xt, d), () => document.removeEventListener(Xt, d)), [d]), u.useEffect(() => {
      if (l.trigger) {
        const p = (m) => {
          m.target?.contains(l.trigger) && d();
        };
        return window.addEventListener("scroll", p, { capture: !0 }), () => window.removeEventListener("scroll", p, { capture: !0 });
      }
    }, [l.trigger, d]), /* @__PURE__ */ c.jsx(
      vt,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: a,
        onFocusOutside: (p) => p.preventDefault(),
        onDismiss: d,
        children: /* @__PURE__ */ c.jsxs(
          co,
          {
            "data-state": l.stateAttribute,
            ...f,
            ...i,
            ref: e,
            style: {
              ...i.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ c.jsx(sl, { children: r }),
              /* @__PURE__ */ c.jsx(rl, { scope: n, isInside: !0, children: /* @__PURE__ */ c.jsx(Xc, { id: l.contentId, role: "tooltip", children: o || r }) })
            ]
          }
        )
      }
    );
  }
);
go.displayName = Ne;
var bo = "TooltipArrow", yo = u.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, o = _t(n);
    return ol(
      bo,
      n
    ).isInside ? null : /* @__PURE__ */ c.jsx(lo, { ...o, ...r, ref: e });
  }
);
yo.displayName = bo;
function al(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), o = Math.abs(e.right - t.x), s = Math.abs(e.left - t.x);
  switch (Math.min(n, r, o, s)) {
    case s:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function il(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      r.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return r;
}
function cl(t) {
  const { top: e, right: n, bottom: r, left: o } = t;
  return [
    { x: o, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: o, y: r }
  ];
}
function ll(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let s = 0, a = e.length - 1; s < e.length; a = s++) {
    const i = e[s], l = e[a], f = i.x, d = i.y, p = l.x, m = l.y;
    d > r != m > r && n < (p - f) * (r - d) / (m - d) + f && (o = !o);
  }
  return o;
}
function ul(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), dl(e);
}
function dl(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], a = e[e.length - 2];
      if ((s.x - a.x) * (o.y - a.y) >= (s.y - a.y) * (o.x - a.x)) e.pop();
      else break;
    }
    e.push(o);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const o = t[r];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1], a = n[n.length - 2];
      if ((s.x - a.x) * (o.y - a.y) >= (s.y - a.y) * (o.x - a.x)) n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var fl = po, pl = mo, ml = ho, hl = vo, vl = go, gl = yo;
function wo(t) {
  const e = A.c(6);
  let n, r;
  e[0] !== t ? ({
    delayDuration: r,
    ...n
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  const o = r === void 0 ? 0 : r;
  let s;
  return e[3] !== o || e[4] !== n ? (s = /* @__PURE__ */ c.jsx(fl, { "data-slot": "tooltip-provider", delayDuration: o, ...n }), e[3] = o, e[4] = n, e[5] = s) : s = e[5], s;
}
function xl(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(wo, { children: /* @__PURE__ */ c.jsx(pl, { "data-slot": "tooltip", ...n }) }), e[2] = n, e[3] = r) : r = e[3], r;
}
function bl(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(ml, { "data-slot": "tooltip-trigger", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function yl(t) {
  const e = A.c(13);
  let n, r, o, s;
  e[0] !== t ? ({
    className: r,
    sideOffset: s,
    children: n,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s) : (n = e[1], r = e[2], o = e[3], s = e[4]);
  const a = s === void 0 ? 4 : s;
  let i;
  e[5] !== r ? (i = L("bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-w-sm rounded-md px-3 py-1.5 text-xs", r), e[5] = r, e[6] = i) : i = e[6];
  let l;
  e[7] === Symbol.for("react.memo_cache_sentinel") ? (l = /* @__PURE__ */ c.jsx(gl, { className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" }), e[7] = l) : l = e[7];
  let f;
  return e[8] !== n || e[9] !== o || e[10] !== a || e[11] !== i ? (f = /* @__PURE__ */ c.jsx(hl, { children: /* @__PURE__ */ c.jsxs(vl, { "data-slot": "tooltip-content", sideOffset: a, className: i, ...o, children: [
    n,
    l
  ] }) }), e[8] = n, e[9] = o, e[10] = a, e[11] = i, e[12] = f) : f = e[12], f;
}
const wl = "sidebar_state", El = 3600 * 24 * 7, Cl = "16rem", Sl = "18rem", _l = "3rem", Rl = "b", Eo = u.createContext(null);
function Rt() {
  const t = u.useContext(Eo);
  if (!t)
    throw new Error("useSidebar must be used within a SidebarProvider.");
  return t;
}
function Al(t) {
  const e = A.c(36);
  let n, r, o, s, a, i, l;
  e[0] !== t ? ({
    defaultOpen: l,
    open: o,
    onOpenChange: a,
    className: r,
    style: i,
    children: n,
    ...s
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s, e[5] = a, e[6] = i, e[7] = l) : (n = e[1], r = e[2], o = e[3], s = e[4], a = e[5], i = e[6], l = e[7]);
  const f = l === void 0 ? !0 : l, d = lr(), [p, m] = u.useState(!1), [h, g] = u.useState(f), v = o ?? h;
  let x;
  e[8] !== v || e[9] !== a ? (x = (k) => {
    const $ = typeof k == "function" ? k(v) : k;
    a ? a($) : g($), document.cookie = `${wl}=${$}; path=/; max-age=${El}`;
  }, e[8] = v, e[9] = a, e[10] = x) : x = e[10];
  const b = x;
  let y;
  e[11] !== d || e[12] !== b ? (y = () => d ? m(Pl) : b(Ml), e[11] = d, e[12] = b, e[13] = y) : y = e[13];
  const w = y;
  let E, C;
  e[14] !== w ? (E = () => {
    const k = ($) => {
      $.key === Rl && ($.metaKey || $.ctrlKey) && ($.preventDefault(), w());
    };
    return window.addEventListener("keydown", k), () => window.removeEventListener("keydown", k);
  }, C = [w], e[14] = w, e[15] = E, e[16] = C) : (E = e[15], C = e[16]), u.useEffect(E, C);
  const _ = v ? "expanded" : "collapsed";
  let S;
  e[17] !== d || e[18] !== v || e[19] !== p || e[20] !== b || e[21] !== _ || e[22] !== w ? (S = {
    state: _,
    open: v,
    setOpen: b,
    isMobile: d,
    openMobile: p,
    setOpenMobile: m,
    toggleSidebar: w
  }, e[17] = d, e[18] = v, e[19] = p, e[20] = b, e[21] = _, e[22] = w, e[23] = S) : S = e[23];
  const M = S;
  let O;
  e[24] !== i ? (O = {
    "--sidebar-width": Cl,
    "--sidebar-width-icon": _l,
    ...i
  }, e[24] = i, e[25] = O) : O = e[25];
  const N = O;
  let D;
  e[26] !== r ? (D = L("group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full", r), e[26] = r, e[27] = D) : D = e[27];
  let j;
  e[28] !== n || e[29] !== s || e[30] !== N || e[31] !== D ? (j = /* @__PURE__ */ c.jsx(wo, { delayDuration: 0, children: /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-wrapper", style: N, className: D, ...s, children: n }) }), e[28] = n, e[29] = s, e[30] = N, e[31] = D, e[32] = j) : j = e[32];
  let I;
  return e[33] !== M || e[34] !== j ? (I = /* @__PURE__ */ c.jsx(Eo.Provider, { value: M, children: j }), e[33] = M, e[34] = j, e[35] = I) : I = e[35], I;
}
function Ml(t) {
  return !t;
}
function Pl(t) {
  return !t;
}
function Ol(t) {
  const e = A.c(46);
  let n, r, o, s, a, i;
  e[0] !== t ? ({
    side: s,
    variant: a,
    collapsible: i,
    className: r,
    children: n,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s, e[5] = a, e[6] = i) : (n = e[1], r = e[2], o = e[3], s = e[4], a = e[5], i = e[6]);
  const l = s === void 0 ? "left" : s, f = a === void 0 ? "sidebar" : a, d = i === void 0 ? "offcanvas" : i, {
    isMobile: p,
    state: m,
    openMobile: h,
    setOpenMobile: g
  } = Rt();
  if (d === "none") {
    let O;
    e[7] !== r ? (O = L("bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col", r), e[7] = r, e[8] = O) : O = e[8];
    let N;
    return e[9] !== n || e[10] !== o || e[11] !== O ? (N = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar", className: O, ...o, children: n }), e[9] = n, e[10] = o, e[11] = O, e[12] = N) : N = e[12], N;
  }
  if (p) {
    let O;
    e[13] === Symbol.for("react.memo_cache_sentinel") ? (O = /* @__PURE__ */ c.jsxs(Ai, { className: "sr-only", children: [
      /* @__PURE__ */ c.jsx(Mi, { children: "Sidebar" }),
      /* @__PURE__ */ c.jsx(Pi, { children: "Displays the mobile sidebar." })
    ] }), e[13] = O) : O = e[13];
    let N;
    e[14] === Symbol.for("react.memo_cache_sentinel") ? (N = {
      "--sidebar-width": Sl
    }, e[14] = N) : N = e[14];
    let D;
    e[15] !== n ? (D = /* @__PURE__ */ c.jsx("div", { className: "flex h-full w-full flex-col", children: n }), e[15] = n, e[16] = D) : D = e[16];
    let j;
    e[17] !== l || e[18] !== D ? (j = /* @__PURE__ */ c.jsx(Ri, { "data-sidebar": "sidebar", "data-slot": "sidebar", "data-mobile": "true", className: "bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden", style: N, side: l, children: D }), e[17] = l, e[18] = D, e[19] = j) : j = e[19];
    let I;
    return e[20] !== h || e[21] !== o || e[22] !== g || e[23] !== j ? (I = /* @__PURE__ */ c.jsxs(Ci, { open: h, onOpenChange: g, ...o, children: [
      O,
      j
    ] }), e[20] = h, e[21] = o, e[22] = g, e[23] = j, e[24] = I) : I = e[24], I;
  }
  const v = m === "collapsed" ? d : "", x = f === "floating" || f === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)";
  let b;
  e[25] !== x ? (b = L("relative h-svh w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear", "group-data-[collapsible=offcanvas]:w-0", "group-data-[side=right]:rotate-180", x), e[25] = x, e[26] = b) : b = e[26];
  let y;
  e[27] !== b ? (y = /* @__PURE__ */ c.jsx("div", { className: b }), e[27] = b, e[28] = y) : y = e[28];
  const w = l === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]", E = f === "floating" || f === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l";
  let C;
  e[29] !== r || e[30] !== w || e[31] !== E ? (C = L("fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex", w, E, r), e[29] = r, e[30] = w, e[31] = E, e[32] = C) : C = e[32];
  let _;
  e[33] !== n ? (_ = /* @__PURE__ */ c.jsx("div", { "data-sidebar": "sidebar", className: "bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm", children: n }), e[33] = n, e[34] = _) : _ = e[34];
  let S;
  e[35] !== o || e[36] !== C || e[37] !== _ ? (S = /* @__PURE__ */ c.jsx("div", { className: C, ...o, children: _ }), e[35] = o, e[36] = C, e[37] = _, e[38] = S) : S = e[38];
  let M;
  return e[39] !== l || e[40] !== m || e[41] !== S || e[42] !== v || e[43] !== y || e[44] !== f ? (M = /* @__PURE__ */ c.jsxs("div", { className: "group peer text-sidebar-foreground hidden md:block", "data-state": m, "data-collapsible": v, "data-variant": f, "data-side": l, "data-slot": "sidebar", children: [
    y,
    S
  ] }), e[39] = l, e[40] = m, e[41] = S, e[42] = v, e[43] = y, e[44] = f, e[45] = M) : M = e[45], M;
}
function Nl(t) {
  const e = A.c(15);
  let n, r, o;
  e[0] !== t ? ({
    className: n,
    onClick: r,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  const {
    toggleSidebar: s
  } = Rt();
  let a;
  e[4] !== n ? (a = L("h-7 w-7", n), e[4] = n, e[5] = a) : a = e[5];
  let i;
  e[6] !== r || e[7] !== s ? (i = (p) => {
    r?.(p), s();
  }, e[6] = r, e[7] = s, e[8] = i) : i = e[8];
  let l, f;
  e[9] === Symbol.for("react.memo_cache_sentinel") ? (l = /* @__PURE__ */ c.jsx(qs, {}), f = /* @__PURE__ */ c.jsx("span", { className: "sr-only", children: "Toggle Sidebar" }), e[9] = l, e[10] = f) : (l = e[9], f = e[10]);
  let d;
  return e[11] !== o || e[12] !== a || e[13] !== i ? (d = /* @__PURE__ */ c.jsxs(Ms, { "data-sidebar": "trigger", "data-slot": "sidebar-trigger", variant: "ghost", size: "icon", className: a, onClick: i, ...o, children: [
    l,
    f
  ] }), e[11] = o, e[12] = a, e[13] = i, e[14] = d) : d = e[14], d;
}
function Tl(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("bg-background relative flex max-w-full min-h-svh flex-1 flex-col", "peer-data-[variant=inset]:min-h-[calc(100svh-(--spacing(4)))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-0", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("main", { "data-slot": "sidebar-inset", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Dl(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("flex flex-col gap-2 p-2", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-header", "data-sidebar": "header", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function jl(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("flex flex-col gap-2 p-2", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-footer", "data-sidebar": "footer", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Il(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-content", "data-sidebar": "content", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Co(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("relative flex w-full min-w-0 flex-col p-2", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-group", "data-sidebar": "group", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Ll(t) {
  const e = A.c(10);
  let n, r, o;
  e[0] !== t ? ({
    className: n,
    asChild: o,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  const a = (o === void 0 ? !1 : o) ? en : "div";
  let i;
  e[4] !== n ? (i = L("text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0", "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 group-data-[collapsible=icon]:select-none group-data-[collapsible=icon]:pointer-events-none", n), e[4] = n, e[5] = i) : i = e[5];
  let l;
  return e[6] !== a || e[7] !== r || e[8] !== i ? (l = /* @__PURE__ */ c.jsx(a, { "data-slot": "sidebar-group-label", "data-sidebar": "group-label", className: i, ...r }), e[6] = a, e[7] = r, e[8] = i, e[9] = l) : l = e[9], l;
}
function kl(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("w-full text-sm", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("div", { "data-slot": "sidebar-group-content", "data-sidebar": "group-content", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function At(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("flex w-full min-w-0 flex-col gap-1", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("ul", { "data-slot": "sidebar-menu", "data-sidebar": "menu", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Mt(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("group/menu-item relative", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("li", { "data-slot": "sidebar-menu-item", "data-sidebar": "menu-item", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
const Fl = As("peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0", {
  variants: {
    variant: {
      default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
      outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
    },
    size: {
      default: "h-8 text-sm",
      sm: "h-7 text-xs",
      lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function Pt(t) {
  const e = A.c(28);
  let n, r, o, s, a, i, l;
  e[0] !== t ? ({
    asChild: o,
    isActive: s,
    variant: a,
    size: i,
    tooltip: l,
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s, e[5] = a, e[6] = i, e[7] = l) : (n = e[1], r = e[2], o = e[3], s = e[4], a = e[5], i = e[6], l = e[7]);
  const f = o === void 0 ? !1 : o, d = s === void 0 ? !1 : s, p = a === void 0 ? "default" : a, m = i === void 0 ? "default" : i, h = f ? en : "button", {
    isMobile: g,
    state: v
  } = Rt();
  let x;
  e[8] !== n || e[9] !== m || e[10] !== p ? (x = L(Fl({
    variant: p,
    size: m
  }), n), e[8] = n, e[9] = m, e[10] = p, e[11] = x) : x = e[11];
  let b;
  e[12] !== h || e[13] !== d || e[14] !== r || e[15] !== m || e[16] !== x ? (b = /* @__PURE__ */ c.jsx(h, { "data-slot": "sidebar-menu-button", "data-sidebar": "menu-button", "data-size": m, "data-active": d, className: x, ...r }), e[12] = h, e[13] = d, e[14] = r, e[15] = m, e[16] = x, e[17] = b) : b = e[17];
  const y = b;
  if (!l)
    return y;
  if (typeof l == "string") {
    let S;
    e[18] !== l ? (S = {
      children: l
    }, e[18] = l, e[19] = S) : S = e[19], l = S;
  }
  let w;
  e[20] !== y ? (w = /* @__PURE__ */ c.jsx(bl, { asChild: !0, children: y }), e[20] = y, e[21] = w) : w = e[21];
  const E = v !== "collapsed" || g;
  let C;
  e[22] !== E || e[23] !== l ? (C = /* @__PURE__ */ c.jsx(yl, { side: "right", align: "center", hidden: E, ...l }), e[22] = E, e[23] = l, e[24] = C) : C = e[24];
  let _;
  return e[25] !== w || e[26] !== C ? (_ = /* @__PURE__ */ c.jsxs(xl, { children: [
    w,
    C
  ] }), e[25] = w, e[26] = C, e[27] = _) : _ = e[27], _;
}
function $l(t) {
  const e = A.c(10);
  let n, r, o;
  if (e[0] !== t ? ({
    variant: o,
    children: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]), (o === void 0 ? "header" : o) === "sidebar") {
    let i;
    return e[4] !== n || e[5] !== r ? (i = /* @__PURE__ */ c.jsx(Tl, { ...r, children: n }), e[4] = n, e[5] = r, e[6] = i) : i = e[6], i;
  }
  let a;
  return e[7] !== n || e[8] !== r ? (a = /* @__PURE__ */ c.jsx("main", { className: "mx-auto flex h-full w-full max-w-7xl flex-1 flex-col gap-4 rounded-xl", ...r, children: n }), e[7] = n, e[8] = r, e[9] = a) : a = e[9], a;
}
function Bl(t) {
  const e = A.c(5), {
    children: n,
    variant: r
  } = t, o = r === void 0 ? "header" : r, s = tn().props.sidebarOpen;
  if (o === "header") {
    let i;
    return e[0] !== n ? (i = /* @__PURE__ */ c.jsx("div", { className: "flex min-h-screen w-full flex-col", children: n }), e[0] = n, e[1] = i) : i = e[1], i;
  }
  let a;
  return e[2] !== n || e[3] !== s ? (a = /* @__PURE__ */ c.jsx(Al, { defaultOpen: s, children: n }), e[2] = n, e[3] = s, e[4] = a) : a = e[4], a;
}
function Hl(t) {
  const e = A.c(10);
  let n, r, o;
  e[0] !== t ? ({
    iconNode: n,
    className: r,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  let s;
  e[4] !== r ? (s = L("h-4 w-4", r), e[4] = r, e[5] = s) : s = e[5];
  let a;
  return e[6] !== n || e[7] !== o || e[8] !== s ? (a = /* @__PURE__ */ c.jsx(n, { className: s, ...o }), e[6] = n, e[7] = o, e[8] = s, e[9] = a) : a = e[9], a;
}
function Wl(t) {
  const e = A.c(12);
  let n, r, o;
  e[0] !== t ? ({
    items: r,
    className: n,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  const s = `group-data-[collapsible=icon]:p-0 ${n || ""}`;
  let a;
  e[4] !== r ? (a = r.map(Gl), e[4] = r, e[5] = a) : a = e[5];
  let i;
  e[6] !== a ? (i = /* @__PURE__ */ c.jsx(kl, { children: /* @__PURE__ */ c.jsx(At, { children: a }) }), e[6] = a, e[7] = i) : i = e[7];
  let l;
  return e[8] !== o || e[9] !== s || e[10] !== i ? (l = /* @__PURE__ */ c.jsx(Co, { ...o, className: s, children: i }), e[8] = o, e[9] = s, e[10] = i, e[11] = l) : l = e[11], l;
}
function Gl(t) {
  return /* @__PURE__ */ c.jsx(Mt, { children: /* @__PURE__ */ c.jsx(Pt, { asChild: !0, className: "text-neutral-600 hover:text-neutral-800 dark:text-neutral-300 dark:hover:text-neutral-100", children: /* @__PURE__ */ c.jsxs("a", { href: sr(t.href), target: "_blank", rel: "noopener noreferrer", children: [
    t.icon && /* @__PURE__ */ c.jsx(Hl, { iconNode: t.icon, className: "h-5 w-5" }),
    /* @__PURE__ */ c.jsx("span", { children: t.title })
  ] }) }) }, t.title);
}
function Kl(t) {
  const e = A.c(10), {
    items: n
  } = t;
  let r;
  e[0] !== n ? (r = n === void 0 ? [] : n, e[0] = n, e[1] = r) : r = e[1];
  const o = r, s = tn();
  let a;
  e[2] === Symbol.for("react.memo_cache_sentinel") ? (a = /* @__PURE__ */ c.jsx(Ll, { children: "Platform" }), e[2] = a) : a = e[2];
  let i;
  if (e[3] !== o || e[4] !== s) {
    let f;
    e[6] !== s ? (f = (d) => /* @__PURE__ */ c.jsx(Mt, { children: /* @__PURE__ */ c.jsx(Pt, { asChild: !0, isActive: s.url.startsWith(sr(d.href)), tooltip: {
      children: d.title
    }, children: /* @__PURE__ */ c.jsxs(Fe, { href: d.href, prefetch: !0, children: [
      d.icon && /* @__PURE__ */ c.jsx(d.icon, {}),
      /* @__PURE__ */ c.jsx("span", { children: d.title })
    ] }) }) }, d.title), e[6] = s, e[7] = f) : f = e[7], i = o.map(f), e[3] = o, e[4] = s, e[5] = i;
  } else
    i = e[5];
  let l;
  return e[8] !== i ? (l = /* @__PURE__ */ c.jsxs(Co, { className: "px-2 py-0", children: [
    a,
    /* @__PURE__ */ c.jsx(At, { children: i })
  ] }), e[8] = i, e[9] = l) : l = e[9], l;
}
function So(t) {
  const e = t + "CollectionProvider", [n, r] = he(e), [o, s] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), a = (v) => {
    const { scope: x, children: b } = v, y = xe.useRef(null), w = xe.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ c.jsx(o, { scope: x, itemMap: w, collectionRef: y, children: b });
  };
  a.displayName = e;
  const i = t + "CollectionSlot", l = it(i), f = xe.forwardRef(
    (v, x) => {
      const { scope: b, children: y } = v, w = s(i, b), E = G(x, w.collectionRef);
      return /* @__PURE__ */ c.jsx(l, { ref: E, children: y });
    }
  );
  f.displayName = i;
  const d = t + "CollectionItemSlot", p = "data-radix-collection-item", m = it(d), h = xe.forwardRef(
    (v, x) => {
      const { scope: b, children: y, ...w } = v, E = xe.useRef(null), C = G(x, E), _ = s(d, b);
      return xe.useEffect(() => (_.itemMap.set(E, { ref: E, ...w }), () => void _.itemMap.delete(E))), /* @__PURE__ */ c.jsx(m, { [p]: "", ref: C, children: y });
    }
  );
  h.displayName = d;
  function g(v) {
    const x = s(t + "CollectionConsumer", v);
    return xe.useCallback(() => {
      const y = x.collectionRef.current;
      if (!y) return [];
      const w = Array.from(y.querySelectorAll(`[${p}]`));
      return Array.from(x.itemMap.values()).sort(
        (_, S) => w.indexOf(_.ref.current) - w.indexOf(S.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [
    { Provider: a, Slot: f, ItemSlot: h },
    g,
    r
  ];
}
var Ul = u.createContext(void 0);
function _o(t) {
  const e = u.useContext(Ul);
  return t || e || "ltr";
}
var Wt = "rovingFocusGroup.onEntryFocus", Vl = { bubbles: !1, cancelable: !0 }, Ve = "RovingFocusGroup", [Zt, Ro, zl] = So(Ve), [Yl, Ao] = he(
  Ve,
  [zl]
), [ql, Xl] = Yl(Ve), Mo = u.forwardRef(
  (t, e) => /* @__PURE__ */ c.jsx(Zt.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ c.jsx(Zt.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ c.jsx(Ql, { ...t, ref: e }) }) })
);
Mo.displayName = Ve;
var Ql = u.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: s,
    currentTabStopId: a,
    defaultCurrentTabStopId: i,
    onCurrentTabStopIdChange: l,
    onEntryFocus: f,
    preventScrollOnEntryFocus: d = !1,
    ...p
  } = t, m = u.useRef(null), h = G(e, m), g = _o(s), [v, x] = ht({
    prop: a,
    defaultProp: i ?? null,
    onChange: l,
    caller: Ve
  }), [b, y] = u.useState(!1), w = se(f), E = Ro(n), C = u.useRef(!1), [_, S] = u.useState(0);
  return u.useEffect(() => {
    const M = m.current;
    if (M)
      return M.addEventListener(Wt, w), () => M.removeEventListener(Wt, w);
  }, [w]), /* @__PURE__ */ c.jsx(
    ql,
    {
      scope: n,
      orientation: r,
      dir: g,
      loop: o,
      currentTabStopId: v,
      onItemFocus: u.useCallback(
        (M) => x(M),
        [x]
      ),
      onItemShiftTab: u.useCallback(() => y(!0), []),
      onFocusableItemAdd: u.useCallback(
        () => S((M) => M + 1),
        []
      ),
      onFocusableItemRemove: u.useCallback(
        () => S((M) => M - 1),
        []
      ),
      children: /* @__PURE__ */ c.jsx(
        B.div,
        {
          tabIndex: b || _ === 0 ? -1 : 0,
          "data-orientation": r,
          ...p,
          ref: h,
          style: { outline: "none", ...t.style },
          onMouseDown: P(t.onMouseDown, () => {
            C.current = !0;
          }),
          onFocus: P(t.onFocus, (M) => {
            const O = !C.current;
            if (M.target === M.currentTarget && O && !b) {
              const N = new CustomEvent(Wt, Vl);
              if (M.currentTarget.dispatchEvent(N), !N.defaultPrevented) {
                const D = E().filter((F) => F.focusable), j = D.find((F) => F.active), I = D.find((F) => F.id === v), $ = [j, I, ...D].filter(
                  Boolean
                ).map((F) => F.ref.current);
                No($, d);
              }
            }
            C.current = !1;
          }),
          onBlur: P(t.onBlur, () => y(!1))
        }
      )
    }
  );
}), Po = "RovingFocusGroupItem", Oo = u.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: s,
      children: a,
      ...i
    } = t, l = be(), f = s || l, d = Xl(Po, n), p = d.currentTabStopId === f, m = Ro(n), { onFocusableItemAdd: h, onFocusableItemRemove: g, currentTabStopId: v } = d;
    return u.useEffect(() => {
      if (r)
        return h(), () => g();
    }, [r, h, g]), /* @__PURE__ */ c.jsx(
      Zt.ItemSlot,
      {
        scope: n,
        id: f,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ c.jsx(
          B.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": d.orientation,
            ...i,
            ref: e,
            onMouseDown: P(t.onMouseDown, (x) => {
              r ? d.onItemFocus(f) : x.preventDefault();
            }),
            onFocus: P(t.onFocus, () => d.onItemFocus(f)),
            onKeyDown: P(t.onKeyDown, (x) => {
              if (x.key === "Tab" && x.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (x.target !== x.currentTarget) return;
              const b = eu(x, d.orientation, d.dir);
              if (b !== void 0) {
                if (x.metaKey || x.ctrlKey || x.altKey || x.shiftKey) return;
                x.preventDefault();
                let w = m().filter((E) => E.focusable).map((E) => E.ref.current);
                if (b === "last") w.reverse();
                else if (b === "prev" || b === "next") {
                  b === "prev" && w.reverse();
                  const E = w.indexOf(x.currentTarget);
                  w = d.loop ? tu(w, E + 1) : w.slice(E + 1);
                }
                setTimeout(() => No(w));
              }
            }),
            children: typeof a == "function" ? a({ isCurrentTabStop: p, hasTabStop: v != null }) : a
          }
        )
      }
    );
  }
);
Oo.displayName = Po;
var Zl = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Jl(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function eu(t, e, n) {
  const r = Jl(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Zl[r];
}
function No(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function tu(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var nu = Mo, ru = Oo, Jt = ["Enter", " "], ou = ["ArrowDown", "PageUp", "Home"], To = ["ArrowUp", "PageDown", "End"], su = [...ou, ...To], au = {
  ltr: [...Jt, "ArrowRight"],
  rtl: [...Jt, "ArrowLeft"]
}, iu = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, ze = "Menu", [We, cu, lu] = So(ze), [Ce, Do] = he(ze, [
  lu,
  Ct,
  Ao
]), Ot = Ct(), jo = Ao(), [uu, Se] = Ce(ze), [du, Ye] = Ce(ze), Io = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: o, onOpenChange: s, modal: a = !0 } = t, i = Ot(e), [l, f] = u.useState(null), d = u.useRef(!1), p = se(s), m = _o(o);
  return u.useEffect(() => {
    const h = () => {
      d.current = !0, document.addEventListener("pointerdown", g, { capture: !0, once: !0 }), document.addEventListener("pointermove", g, { capture: !0, once: !0 });
    }, g = () => d.current = !1;
    return document.addEventListener("keydown", h, { capture: !0 }), () => {
      document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", g, { capture: !0 }), document.removeEventListener("pointermove", g, { capture: !0 });
    };
  }, []), /* @__PURE__ */ c.jsx(ao, { ...i, children: /* @__PURE__ */ c.jsx(
    uu,
    {
      scope: e,
      open: n,
      onOpenChange: p,
      content: l,
      onContentChange: f,
      children: /* @__PURE__ */ c.jsx(
        du,
        {
          scope: e,
          onClose: u.useCallback(() => p(!1), [p]),
          isUsingKeyboardRef: d,
          dir: m,
          modal: a,
          children: r
        }
      )
    }
  ) });
};
Io.displayName = ze;
var fu = "MenuAnchor", yn = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ot(n);
    return /* @__PURE__ */ c.jsx(io, { ...o, ...r, ref: e });
  }
);
yn.displayName = fu;
var wn = "MenuPortal", [pu, Lo] = Ce(wn, {
  forceMount: void 0
}), ko = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: o } = t, s = Se(wn, e);
  return /* @__PURE__ */ c.jsx(pu, { scope: e, forceMount: n, children: /* @__PURE__ */ c.jsx(de, { present: n || s.open, children: /* @__PURE__ */ c.jsx(gt, { asChild: !0, container: o, children: r }) }) });
};
ko.displayName = wn;
var q = "MenuContent", [mu, En] = Ce(q), Fo = u.forwardRef(
  (t, e) => {
    const n = Lo(q, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, s = Se(q, t.__scopeMenu), a = Ye(q, t.__scopeMenu);
    return /* @__PURE__ */ c.jsx(We.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ c.jsx(de, { present: r || s.open, children: /* @__PURE__ */ c.jsx(We.Slot, { scope: t.__scopeMenu, children: a.modal ? /* @__PURE__ */ c.jsx(hu, { ...o, ref: e }) : /* @__PURE__ */ c.jsx(vu, { ...o, ref: e }) }) }) });
  }
), hu = u.forwardRef(
  (t, e) => {
    const n = Se(q, t.__scopeMenu), r = u.useRef(null), o = G(e, r);
    return u.useEffect(() => {
      const s = r.current;
      if (s) return Er(s);
    }, []), /* @__PURE__ */ c.jsx(
      Cn,
      {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: P(
          t.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), vu = u.forwardRef((t, e) => {
  const n = Se(q, t.__scopeMenu);
  return /* @__PURE__ */ c.jsx(
    Cn,
    {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), gu = it("MenuContent.ScrollLock"), Cn = u.forwardRef(
  (t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: s,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: i,
      onEntryFocus: l,
      onEscapeKeyDown: f,
      onPointerDownOutside: d,
      onFocusOutside: p,
      onInteractOutside: m,
      onDismiss: h,
      disableOutsideScroll: g,
      ...v
    } = t, x = Se(q, n), b = Ye(q, n), y = Ot(n), w = jo(n), E = cu(n), [C, _] = u.useState(null), S = u.useRef(null), M = G(e, S, x.onContentChange), O = u.useRef(0), N = u.useRef(""), D = u.useRef(0), j = u.useRef(null), I = u.useRef("right"), k = u.useRef(0), $ = g ? on : u.Fragment, F = g ? { as: gu, allowPinchZoom: !0 } : void 0, H = (R) => {
      const K = N.current + R, te = E().filter((W) => !W.disabled), ve = document.activeElement, je = te.find((W) => W.ref.current === ve)?.textValue, Ie = te.map((W) => W.textValue), qe = Pu(Ie, K, je), ge = te.find((W) => W.textValue === qe)?.ref.current;
      (function W(Le) {
        N.current = Le, window.clearTimeout(O.current), Le !== "" && (O.current = window.setTimeout(() => W(""), 1e3));
      })(K), ge && setTimeout(() => ge.focus());
    };
    u.useEffect(() => () => window.clearTimeout(O.current), []), pr();
    const T = u.useCallback((R) => I.current === j.current?.side && Nu(R, j.current?.area), []);
    return /* @__PURE__ */ c.jsx(
      mu,
      {
        scope: n,
        searchRef: N,
        onItemEnter: u.useCallback(
          (R) => {
            T(R) && R.preventDefault();
          },
          [T]
        ),
        onItemLeave: u.useCallback(
          (R) => {
            T(R) || (S.current?.focus(), _(null));
          },
          [T]
        ),
        onTriggerLeave: u.useCallback(
          (R) => {
            T(R) && R.preventDefault();
          },
          [T]
        ),
        pointerGraceTimerRef: D,
        onPointerGraceIntentChange: u.useCallback((R) => {
          j.current = R;
        }, []),
        children: /* @__PURE__ */ c.jsx($, { ...F, children: /* @__PURE__ */ c.jsx(
          rn,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: P(s, (R) => {
              R.preventDefault(), S.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: a,
            children: /* @__PURE__ */ c.jsx(
              vt,
              {
                asChild: !0,
                disableOutsidePointerEvents: i,
                onEscapeKeyDown: f,
                onPointerDownOutside: d,
                onFocusOutside: p,
                onInteractOutside: m,
                onDismiss: h,
                children: /* @__PURE__ */ c.jsx(
                  nu,
                  {
                    asChild: !0,
                    ...w,
                    dir: b.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: C,
                    onCurrentTabStopIdChange: _,
                    onEntryFocus: P(l, (R) => {
                      b.isUsingKeyboardRef.current || R.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ c.jsx(
                      co,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": es(x.open),
                        "data-radix-menu-content": "",
                        dir: b.dir,
                        ...y,
                        ...v,
                        ref: M,
                        style: { outline: "none", ...v.style },
                        onKeyDown: P(v.onKeyDown, (R) => {
                          const te = R.target.closest("[data-radix-menu-content]") === R.currentTarget, ve = R.ctrlKey || R.altKey || R.metaKey, je = R.key.length === 1;
                          te && (R.key === "Tab" && R.preventDefault(), !ve && je && H(R.key));
                          const Ie = S.current;
                          if (R.target !== Ie || !su.includes(R.key)) return;
                          R.preventDefault();
                          const ge = E().filter((W) => !W.disabled).map((W) => W.ref.current);
                          To.includes(R.key) && ge.reverse(), Au(ge);
                        }),
                        onBlur: P(t.onBlur, (R) => {
                          R.currentTarget.contains(R.target) || (window.clearTimeout(O.current), N.current = "");
                        }),
                        onPointerMove: P(
                          t.onPointerMove,
                          Ge((R) => {
                            const K = R.target, te = k.current !== R.clientX;
                            if (R.currentTarget.contains(K) && te) {
                              const ve = R.clientX > k.current ? "right" : "left";
                              I.current = ve, k.current = R.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Fo.displayName = q;
var xu = "MenuGroup", Sn = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ c.jsx(B.div, { role: "group", ...r, ref: e });
  }
);
Sn.displayName = xu;
var bu = "MenuLabel", $o = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ c.jsx(B.div, { ...r, ref: e });
  }
);
$o.displayName = bu;
var pt = "MenuItem", Qn = "menu.itemSelect", Nt = u.forwardRef(
  (t, e) => {
    const { disabled: n = !1, onSelect: r, ...o } = t, s = u.useRef(null), a = Ye(pt, t.__scopeMenu), i = En(pt, t.__scopeMenu), l = G(e, s), f = u.useRef(!1), d = () => {
      const p = s.current;
      if (!n && p) {
        const m = new CustomEvent(Qn, { bubbles: !0, cancelable: !0 });
        p.addEventListener(Qn, (h) => r?.(h), { once: !0 }), ir(p, m), m.defaultPrevented ? f.current = !1 : a.onClose();
      }
    };
    return /* @__PURE__ */ c.jsx(
      Bo,
      {
        ...o,
        ref: l,
        disabled: n,
        onClick: P(t.onClick, d),
        onPointerDown: (p) => {
          t.onPointerDown?.(p), f.current = !0;
        },
        onPointerUp: P(t.onPointerUp, (p) => {
          f.current || p.currentTarget?.click();
        }),
        onKeyDown: P(t.onKeyDown, (p) => {
          const m = i.searchRef.current !== "";
          n || m && p.key === " " || Jt.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
        })
      }
    );
  }
);
Nt.displayName = pt;
var Bo = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...s } = t, a = En(pt, n), i = jo(n), l = u.useRef(null), f = G(e, l), [d, p] = u.useState(!1), [m, h] = u.useState("");
    return u.useEffect(() => {
      const g = l.current;
      g && h((g.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ c.jsx(
      We.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? m,
        children: /* @__PURE__ */ c.jsx(ru, { asChild: !0, ...i, focusable: !r, children: /* @__PURE__ */ c.jsx(
          B.div,
          {
            role: "menuitem",
            "data-highlighted": d ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: f,
            onPointerMove: P(
              t.onPointerMove,
              Ge((g) => {
                r ? a.onItemLeave(g) : (a.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: P(
              t.onPointerLeave,
              Ge((g) => a.onItemLeave(g))
            ),
            onFocus: P(t.onFocus, () => p(!0)),
            onBlur: P(t.onBlur, () => p(!1))
          }
        ) })
      }
    );
  }
), yu = "MenuCheckboxItem", Ho = u.forwardRef(
  (t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = t;
    return /* @__PURE__ */ c.jsx(Vo, { scope: t.__scopeMenu, checked: n, children: /* @__PURE__ */ c.jsx(
      Nt,
      {
        role: "menuitemcheckbox",
        "aria-checked": mt(n) ? "mixed" : n,
        ...o,
        ref: e,
        "data-state": Rn(n),
        onSelect: P(
          o.onSelect,
          () => r?.(mt(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Ho.displayName = yu;
var Wo = "MenuRadioGroup", [wu, Eu] = Ce(
  Wo,
  { value: void 0, onValueChange: () => {
  } }
), Go = u.forwardRef(
  (t, e) => {
    const { value: n, onValueChange: r, ...o } = t, s = se(r);
    return /* @__PURE__ */ c.jsx(wu, { scope: t.__scopeMenu, value: n, onValueChange: s, children: /* @__PURE__ */ c.jsx(Sn, { ...o, ref: e }) });
  }
);
Go.displayName = Wo;
var Ko = "MenuRadioItem", Uo = u.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, o = Eu(Ko, t.__scopeMenu), s = n === o.value;
    return /* @__PURE__ */ c.jsx(Vo, { scope: t.__scopeMenu, checked: s, children: /* @__PURE__ */ c.jsx(
      Nt,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: e,
        "data-state": Rn(s),
        onSelect: P(
          r.onSelect,
          () => o.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Uo.displayName = Ko;
var _n = "MenuItemIndicator", [Vo, Cu] = Ce(
  _n,
  { checked: !1 }
), zo = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, forceMount: r, ...o } = t, s = Cu(_n, n);
    return /* @__PURE__ */ c.jsx(
      de,
      {
        present: r || mt(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ c.jsx(
          B.span,
          {
            ...o,
            ref: e,
            "data-state": Rn(s.checked)
          }
        )
      }
    );
  }
);
zo.displayName = _n;
var Su = "MenuSeparator", Yo = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ c.jsx(
      B.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
Yo.displayName = Su;
var _u = "MenuArrow", qo = u.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ot(n);
    return /* @__PURE__ */ c.jsx(lo, { ...o, ...r, ref: e });
  }
);
qo.displayName = _u;
var Ru = "MenuSub", [bf, Xo] = Ce(Ru), ke = "MenuSubTrigger", Qo = u.forwardRef(
  (t, e) => {
    const n = Se(ke, t.__scopeMenu), r = Ye(ke, t.__scopeMenu), o = Xo(ke, t.__scopeMenu), s = En(ke, t.__scopeMenu), a = u.useRef(null), { pointerGraceTimerRef: i, onPointerGraceIntentChange: l } = s, f = { __scopeMenu: t.__scopeMenu }, d = u.useCallback(() => {
      a.current && window.clearTimeout(a.current), a.current = null;
    }, []);
    return u.useEffect(() => d, [d]), u.useEffect(() => {
      const p = i.current;
      return () => {
        window.clearTimeout(p), l(null);
      };
    }, [i, l]), /* @__PURE__ */ c.jsx(yn, { asChild: !0, ...f, children: /* @__PURE__ */ c.jsx(
      Bo,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": es(n.open),
        ...t,
        ref: ar(e, o.onTriggerChange),
        onClick: (p) => {
          t.onClick?.(p), !(t.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: P(
          t.onPointerMove,
          Ge((p) => {
            s.onItemEnter(p), !p.defaultPrevented && !t.disabled && !n.open && !a.current && (s.onPointerGraceIntentChange(null), a.current = window.setTimeout(() => {
              n.onOpenChange(!0), d();
            }, 100));
          })
        ),
        onPointerLeave: P(
          t.onPointerLeave,
          Ge((p) => {
            d();
            const m = n.content?.getBoundingClientRect();
            if (m) {
              const h = n.content?.dataset.side, g = h === "right", v = g ? -5 : 5, x = m[g ? "left" : "right"], b = m[g ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: p.clientX + v, y: p.clientY },
                  { x, y: m.top },
                  { x: b, y: m.top },
                  { x: b, y: m.bottom },
                  { x, y: m.bottom }
                ],
                side: h
              }), window.clearTimeout(i.current), i.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(p), p.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: P(t.onKeyDown, (p) => {
          const m = s.searchRef.current !== "";
          t.disabled || m && p.key === " " || au[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
        })
      }
    ) });
  }
);
Qo.displayName = ke;
var Zo = "MenuSubContent", Jo = u.forwardRef(
  (t, e) => {
    const n = Lo(q, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, s = Se(q, t.__scopeMenu), a = Ye(q, t.__scopeMenu), i = Xo(Zo, t.__scopeMenu), l = u.useRef(null), f = G(e, l);
    return /* @__PURE__ */ c.jsx(We.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ c.jsx(de, { present: r || s.open, children: /* @__PURE__ */ c.jsx(We.Slot, { scope: t.__scopeMenu, children: /* @__PURE__ */ c.jsx(
      Cn,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ref: f,
        align: "start",
        side: a.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (d) => {
          a.isUsingKeyboardRef.current && l.current?.focus(), d.preventDefault();
        },
        onCloseAutoFocus: (d) => d.preventDefault(),
        onFocusOutside: P(t.onFocusOutside, (d) => {
          d.target !== i.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: P(t.onEscapeKeyDown, (d) => {
          a.onClose(), d.preventDefault();
        }),
        onKeyDown: P(t.onKeyDown, (d) => {
          const p = d.currentTarget.contains(d.target), m = iu[a.dir].includes(d.key);
          p && m && (s.onOpenChange(!1), i.trigger?.focus(), d.preventDefault());
        })
      }
    ) }) }) });
  }
);
Jo.displayName = Zo;
function es(t) {
  return t ? "open" : "closed";
}
function mt(t) {
  return t === "indeterminate";
}
function Rn(t) {
  return mt(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function Au(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function Mu(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function Pu(t, e, n) {
  const o = e.length > 1 && Array.from(e).every((f) => f === e[0]) ? e[0] : e, s = n ? t.indexOf(n) : -1;
  let a = Mu(t, Math.max(s, 0));
  o.length === 1 && (a = a.filter((f) => f !== n));
  const l = a.find(
    (f) => f.toLowerCase().startsWith(o.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function Ou(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let s = 0, a = e.length - 1; s < e.length; a = s++) {
    const i = e[s], l = e[a], f = i.x, d = i.y, p = l.x, m = l.y;
    d > r != m > r && n < (p - f) * (r - d) / (m - d) + f && (o = !o);
  }
  return o;
}
function Nu(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return Ou(n, e);
}
function Ge(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
var Tu = Io, Du = yn, ju = ko, Iu = Fo, Lu = Sn, ku = $o, Fu = Nt, $u = Ho, Bu = Go, Hu = Uo, Wu = zo, Gu = Yo, Ku = qo, Uu = Qo, Vu = Jo, Tt = "DropdownMenu", [zu, yf] = he(
  Tt,
  [Do]
), V = Do(), [Yu, ts] = zu(Tt), ns = (t) => {
  const {
    __scopeDropdownMenu: e,
    children: n,
    dir: r,
    open: o,
    defaultOpen: s,
    onOpenChange: a,
    modal: i = !0
  } = t, l = V(e), f = u.useRef(null), [d, p] = ht({
    prop: o,
    defaultProp: s ?? !1,
    onChange: a,
    caller: Tt
  });
  return /* @__PURE__ */ c.jsx(
    Yu,
    {
      scope: e,
      triggerId: be(),
      triggerRef: f,
      contentId: be(),
      open: d,
      onOpenChange: p,
      onOpenToggle: u.useCallback(() => p((m) => !m), [p]),
      modal: i,
      children: /* @__PURE__ */ c.jsx(Tu, { ...l, open: d, onOpenChange: p, dir: r, modal: i, children: n })
    }
  );
};
ns.displayName = Tt;
var rs = "DropdownMenuTrigger", os = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = t, s = ts(rs, n), a = V(n);
    return /* @__PURE__ */ c.jsx(Du, { asChild: !0, ...a, children: /* @__PURE__ */ c.jsx(
      B.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: ar(e, s.triggerRef),
        onPointerDown: P(t.onPointerDown, (i) => {
          !r && i.button === 0 && i.ctrlKey === !1 && (s.onOpenToggle(), s.open || i.preventDefault());
        }),
        onKeyDown: P(t.onKeyDown, (i) => {
          r || (["Enter", " "].includes(i.key) && s.onOpenToggle(), i.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(i.key) && i.preventDefault());
        })
      }
    ) });
  }
);
os.displayName = rs;
var qu = "DropdownMenuPortal", ss = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = V(e);
  return /* @__PURE__ */ c.jsx(ju, { ...r, ...n });
};
ss.displayName = qu;
var as = "DropdownMenuContent", is = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = ts(as, n), s = V(n), a = u.useRef(!1);
    return /* @__PURE__ */ c.jsx(
      Iu,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...s,
        ...r,
        ref: e,
        onCloseAutoFocus: P(t.onCloseAutoFocus, (i) => {
          a.current || o.triggerRef.current?.focus(), a.current = !1, i.preventDefault();
        }),
        onInteractOutside: P(t.onInteractOutside, (i) => {
          const l = i.detail.originalEvent, f = l.button === 0 && l.ctrlKey === !0, d = l.button === 2 || f;
          (!o.modal || d) && (a.current = !0);
        }),
        style: {
          ...t.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
is.displayName = as;
var Xu = "DropdownMenuGroup", cs = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
    return /* @__PURE__ */ c.jsx(Lu, { ...o, ...r, ref: e });
  }
);
cs.displayName = Xu;
var Qu = "DropdownMenuLabel", ls = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
    return /* @__PURE__ */ c.jsx(ku, { ...o, ...r, ref: e });
  }
);
ls.displayName = Qu;
var Zu = "DropdownMenuItem", us = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
    return /* @__PURE__ */ c.jsx(Fu, { ...o, ...r, ref: e });
  }
);
us.displayName = Zu;
var Ju = "DropdownMenuCheckboxItem", ed = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx($u, { ...o, ...r, ref: e });
});
ed.displayName = Ju;
var td = "DropdownMenuRadioGroup", nd = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(Bu, { ...o, ...r, ref: e });
});
nd.displayName = td;
var rd = "DropdownMenuRadioItem", od = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(Hu, { ...o, ...r, ref: e });
});
od.displayName = rd;
var sd = "DropdownMenuItemIndicator", ad = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(Wu, { ...o, ...r, ref: e });
});
ad.displayName = sd;
var id = "DropdownMenuSeparator", ds = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(Gu, { ...o, ...r, ref: e });
});
ds.displayName = id;
var cd = "DropdownMenuArrow", ld = u.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
    return /* @__PURE__ */ c.jsx(Ku, { ...o, ...r, ref: e });
  }
);
ld.displayName = cd;
var ud = "DropdownMenuSubTrigger", dd = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(Uu, { ...o, ...r, ref: e });
});
dd.displayName = ud;
var fd = "DropdownMenuSubContent", pd = u.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = V(n);
  return /* @__PURE__ */ c.jsx(
    Vu,
    {
      ...o,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
pd.displayName = fd;
var md = ns, hd = os, vd = ss, gd = is, xd = cs, bd = ls, yd = us, wd = ds;
function Ed(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(md, { "data-slot": "dropdown-menu", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function Cd(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(hd, { "data-slot": "dropdown-menu-trigger", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function Sd(t) {
  const e = A.c(10);
  let n, r, o;
  e[0] !== t ? ({
    className: n,
    sideOffset: o,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  const s = o === void 0 ? 4 : o;
  let a;
  e[4] !== n ? (a = L("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md", n), e[4] = n, e[5] = a) : a = e[5];
  let i;
  return e[6] !== r || e[7] !== s || e[8] !== a ? (i = /* @__PURE__ */ c.jsx(vd, { children: /* @__PURE__ */ c.jsx(gd, { "data-slot": "dropdown-menu-content", sideOffset: s, className: a, ...r }) }), e[6] = r, e[7] = s, e[8] = a, e[9] = i) : i = e[9], i;
}
function _d(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx(xd, { "data-slot": "dropdown-menu-group", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function Zn(t) {
  const e = A.c(12);
  let n, r, o, s;
  e[0] !== t ? ({
    className: n,
    inset: r,
    variant: s,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o, e[4] = s) : (n = e[1], r = e[2], o = e[3], s = e[4]);
  const a = s === void 0 ? "default" : s;
  let i;
  e[5] !== n ? (i = L("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", n), e[5] = n, e[6] = i) : i = e[6];
  let l;
  return e[7] !== r || e[8] !== o || e[9] !== i || e[10] !== a ? (l = /* @__PURE__ */ c.jsx(yd, { "data-slot": "dropdown-menu-item", "data-inset": r, "data-variant": a, className: i, ...o }), e[7] = r, e[8] = o, e[9] = i, e[10] = a, e[11] = l) : l = e[11], l;
}
function Rd(t) {
  const e = A.c(10);
  let n, r, o;
  e[0] !== t ? ({
    className: n,
    inset: r,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  let s;
  e[4] !== n ? (s = L("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", n), e[4] = n, e[5] = s) : s = e[5];
  let a;
  return e[6] !== r || e[7] !== o || e[8] !== s ? (a = /* @__PURE__ */ c.jsx(bd, { "data-slot": "dropdown-menu-label", "data-inset": r, className: s, ...o }), e[6] = r, e[7] = o, e[8] = s, e[9] = a) : a = e[9], a;
}
function Jn(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("bg-border -mx-1 my-1 h-px", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(wd, { "data-slot": "dropdown-menu-separator", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
var nt = { exports: {} }, Gt = {};
var er;
function Ad() {
  if (er) return Gt;
  er = 1;
  var t = or();
  function e(p, m) {
    return p === m && (p !== 0 || 1 / p === 1 / m) || p !== p && m !== m;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, o = t.useEffect, s = t.useLayoutEffect, a = t.useDebugValue;
  function i(p, m) {
    var h = m(), g = r({ inst: { value: h, getSnapshot: m } }), v = g[0].inst, x = g[1];
    return s(
      function() {
        v.value = h, v.getSnapshot = m, l(v) && x({ inst: v });
      },
      [p, h, m]
    ), o(
      function() {
        return l(v) && x({ inst: v }), p(function() {
          l(v) && x({ inst: v });
        });
      },
      [p]
    ), a(h), h;
  }
  function l(p) {
    var m = p.getSnapshot;
    p = p.value;
    try {
      var h = m();
      return !n(p, h);
    } catch {
      return !0;
    }
  }
  function f(p, m) {
    return m();
  }
  var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : i;
  return Gt.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : d, Gt;
}
var Kt = {};
var tr;
function Md() {
  return tr || (tr = 1, process.env.NODE_ENV !== "production" && (function() {
    function t(h, g) {
      return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g;
    }
    function e(h, g) {
      d || o.startTransition === void 0 || (d = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var v = g();
      if (!p) {
        var x = g();
        s(v, x) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), p = !0);
      }
      x = a({
        inst: { value: v, getSnapshot: g }
      });
      var b = x[0].inst, y = x[1];
      return l(
        function() {
          b.value = v, b.getSnapshot = g, n(b) && y({ inst: b });
        },
        [h, v, g]
      ), i(
        function() {
          return n(b) && y({ inst: b }), h(function() {
            n(b) && y({ inst: b });
          });
        },
        [h]
      ), f(v), v;
    }
    function n(h) {
      var g = h.getSnapshot;
      h = h.value;
      try {
        var v = g();
        return !s(h, v);
      } catch {
        return !0;
      }
    }
    function r(h, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var o = or(), s = typeof Object.is == "function" ? Object.is : t, a = o.useState, i = o.useEffect, l = o.useLayoutEffect, f = o.useDebugValue, d = !1, p = !1, m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    Kt.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : m, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), Kt;
}
var nr;
function Pd() {
  return nr || (nr = 1, process.env.NODE_ENV === "production" ? nt.exports = Ad() : nt.exports = Md()), nt.exports;
}
var Od = Pd();
function Nd() {
  return Od.useSyncExternalStore(
    Td,
    () => !0,
    () => !1
  );
}
function Td() {
  return () => {
  };
}
var An = "Avatar", [Dd, wf] = he(An), [jd, fs] = Dd(An), ps = u.forwardRef(
  (t, e) => {
    const { __scopeAvatar: n, ...r } = t, [o, s] = u.useState("idle");
    return /* @__PURE__ */ c.jsx(
      jd,
      {
        scope: n,
        imageLoadingStatus: o,
        onImageLoadingStatusChange: s,
        children: /* @__PURE__ */ c.jsx(B.span, { ...r, ref: e })
      }
    );
  }
);
ps.displayName = An;
var ms = "AvatarImage", hs = u.forwardRef(
  (t, e) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: o = () => {
    }, ...s } = t, a = fs(ms, n), i = Id(r, s), l = se((f) => {
      o(f), a.onImageLoadingStatusChange(f);
    });
    return ye(() => {
      i !== "idle" && l(i);
    }, [i, l]), i === "loaded" ? /* @__PURE__ */ c.jsx(B.img, { ...s, ref: e, src: r }) : null;
  }
);
hs.displayName = ms;
var vs = "AvatarFallback", gs = u.forwardRef(
  (t, e) => {
    const { __scopeAvatar: n, delayMs: r, ...o } = t, s = fs(vs, n), [a, i] = u.useState(r === void 0);
    return u.useEffect(() => {
      if (r !== void 0) {
        const l = window.setTimeout(() => i(!0), r);
        return () => window.clearTimeout(l);
      }
    }, [r]), a && s.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ c.jsx(B.span, { ...o, ref: e }) : null;
  }
);
gs.displayName = vs;
function rr(t, e) {
  return t ? e ? (t.src !== e && (t.src = e), t.complete && t.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function Id(t, { referrerPolicy: e, crossOrigin: n }) {
  const r = Nd(), o = u.useRef(null), s = r ? (o.current || (o.current = new window.Image()), o.current) : null, [a, i] = u.useState(
    () => rr(s, t)
  );
  return ye(() => {
    i(rr(s, t));
  }, [s, t]), ye(() => {
    const l = (p) => () => {
      i(p);
    };
    if (!s) return;
    const f = l("loaded"), d = l("error");
    return s.addEventListener("load", f), s.addEventListener("error", d), e && (s.referrerPolicy = e), typeof n == "string" && (s.crossOrigin = n), () => {
      s.removeEventListener("load", f), s.removeEventListener("error", d);
    };
  }, [s, n, e]), a;
}
var Ld = ps, kd = hs, Fd = gs;
function $d(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("relative flex size-8 shrink-0 overflow-hidden rounded-full", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(Ld, { "data-slot": "avatar", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Bd(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("aspect-square size-full", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(kd, { "data-slot": "avatar-image", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Hd(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("bg-muted flex size-full items-center justify-center rounded-full", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx(Fd, { "data-slot": "avatar-fallback", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function Wd() {
  return Gd;
}
function Gd(t) {
  const e = t.trim().split(" ");
  if (e.length === 0)
    return "";
  if (e.length === 1)
    return e[0].charAt(0).toUpperCase();
  const n = e[0].charAt(0), r = e[e.length - 1].charAt(0);
  return `${n}${r}`.toUpperCase();
}
function xs(t) {
  const e = A.c(22), {
    user: n,
    showEmail: r
  } = t, o = r === void 0 ? !1 : r, s = Wd();
  let a;
  e[0] !== n.avatar || e[1] !== n.name ? (a = /* @__PURE__ */ c.jsx(Bd, { src: n.avatar, alt: n.name }), e[0] = n.avatar, e[1] = n.name, e[2] = a) : a = e[2];
  let i;
  e[3] !== s || e[4] !== n.name ? (i = s(n.name), e[3] = s, e[4] = n.name, e[5] = i) : i = e[5];
  let l;
  e[6] !== i ? (l = /* @__PURE__ */ c.jsx(Hd, { className: "rounded-lg bg-neutral-200 text-black dark:bg-neutral-700 dark:text-white", children: i }), e[6] = i, e[7] = l) : l = e[7];
  let f;
  e[8] !== a || e[9] !== l ? (f = /* @__PURE__ */ c.jsxs($d, { className: "h-8 w-8 overflow-hidden rounded-full", children: [
    a,
    l
  ] }), e[8] = a, e[9] = l, e[10] = f) : f = e[10];
  let d;
  e[11] !== n.name ? (d = /* @__PURE__ */ c.jsx("span", { className: "truncate font-medium", children: n.name }), e[11] = n.name, e[12] = d) : d = e[12];
  let p;
  e[13] !== o || e[14] !== n.email ? (p = o && /* @__PURE__ */ c.jsx("span", { className: "truncate text-xs text-muted-foreground", children: n.email }), e[13] = o, e[14] = n.email, e[15] = p) : p = e[15];
  let m;
  e[16] !== d || e[17] !== p ? (m = /* @__PURE__ */ c.jsxs("div", { className: "grid flex-1 text-left text-sm leading-tight", children: [
    d,
    p
  ] }), e[16] = d, e[17] = p, e[18] = m) : m = e[18];
  let h;
  return e[19] !== f || e[20] !== m ? (h = /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
    f,
    m
  ] }), e[19] = f, e[20] = m, e[21] = h) : h = e[21], h;
}
function Kd() {
  return Ud;
}
function Ud() {
  document.body.style.removeProperty("pointer-events");
}
const U = (t) => ({
  url: U.url(t),
  method: "get"
});
U.definition = {
  methods: ["get", "head"],
  url: "/settings/profile"
};
U.url = (t) => U.definition.url + nn(t);
U.get = (t) => ({
  url: U.url(t),
  method: "get"
});
U.head = (t) => ({
  url: U.url(t),
  method: "head"
});
const Mn = (t) => ({
  action: U.url(t),
  method: "get"
});
Mn.get = (t) => ({
  action: U.url(t),
  method: "get"
});
Mn.head = (t) => ({
  action: U.url({
    [t?.mergeQuery ? "mergeQuery" : "query"]: {
      _method: "HEAD",
      ...t?.query ?? t?.mergeQuery ?? {}
    }
  }),
  method: "get"
});
U.form = Mn;
const Z = (t) => ({
  url: Z.url(t),
  method: "patch"
});
Z.definition = {
  methods: ["patch"],
  url: "/settings/profile"
};
Z.url = (t) => Z.definition.url + nn(t);
Z.patch = (t) => ({
  url: Z.url(t),
  method: "patch"
});
const bs = (t) => ({
  action: Z.url({
    [t?.mergeQuery ? "mergeQuery" : "query"]: {
      _method: "PATCH",
      ...t?.query ?? t?.mergeQuery ?? {}
    }
  }),
  method: "post"
});
bs.patch = (t) => ({
  action: Z.url({
    [t?.mergeQuery ? "mergeQuery" : "query"]: {
      _method: "PATCH",
      ...t?.query ?? t?.mergeQuery ?? {}
    }
  }),
  method: "post"
});
Z.form = bs;
const J = (t) => ({
  url: J.url(t),
  method: "delete"
});
J.definition = {
  methods: ["delete"],
  url: "/settings/profile"
};
J.url = (t) => J.definition.url + nn(t);
J.delete = (t) => ({
  url: J.url(t),
  method: "delete"
});
const ys = (t) => ({
  action: J.url({
    [t?.mergeQuery ? "mergeQuery" : "query"]: {
      _method: "DELETE",
      ...t?.query ?? t?.mergeQuery ?? {}
    }
  }),
  method: "post"
});
ys.delete = (t) => ({
  action: J.url({
    [t?.mergeQuery ? "mergeQuery" : "query"]: {
      _method: "DELETE",
      ...t?.query ?? t?.mergeQuery ?? {}
    }
  }),
  method: "post"
});
J.form = ys;
Object.assign(U, U), Object.assign(Z, Z), Object.assign(J, J);
function Vd(t) {
  const e = A.c(18), {
    user: n
  } = t, r = Kd();
  let o;
  e[0] !== r ? (o = () => {
    r(), js.flushAll();
  }, e[0] = r, e[1] = o) : o = e[1];
  const s = o;
  let a;
  e[2] !== n ? (a = /* @__PURE__ */ c.jsx(Rd, { className: "p-0 font-normal", children: /* @__PURE__ */ c.jsx("div", { className: "flex items-center gap-2 px-1 py-1.5 text-left text-sm", children: /* @__PURE__ */ c.jsx(xs, { user: n, showEmail: !0 }) }) }), e[2] = n, e[3] = a) : a = e[3];
  let i;
  e[4] === Symbol.for("react.memo_cache_sentinel") ? (i = /* @__PURE__ */ c.jsx(Jn, {}), e[4] = i) : i = e[4];
  let l;
  e[5] === Symbol.for("react.memo_cache_sentinel") ? (l = U(), e[5] = l) : l = e[5];
  let f;
  e[6] === Symbol.for("react.memo_cache_sentinel") ? (f = /* @__PURE__ */ c.jsx(Qs, { className: "mr-2" }), e[6] = f) : f = e[6];
  let d;
  e[7] !== r ? (d = /* @__PURE__ */ c.jsx(_d, { children: /* @__PURE__ */ c.jsx(Zn, { asChild: !0, children: /* @__PURE__ */ c.jsxs(Fe, { className: "block w-full", href: l, as: "button", prefetch: !0, onClick: r, children: [
    f,
    "Settings"
  ] }) }) }), e[7] = r, e[8] = d) : d = e[8];
  let p;
  e[9] === Symbol.for("react.memo_cache_sentinel") ? (p = /* @__PURE__ */ c.jsx(Jn, {}), e[9] = p) : p = e[9];
  let m;
  e[10] === Symbol.for("react.memo_cache_sentinel") ? (m = Is(), e[10] = m) : m = e[10];
  let h;
  e[11] === Symbol.for("react.memo_cache_sentinel") ? (h = /* @__PURE__ */ c.jsx(zs, { className: "mr-2" }), e[11] = h) : h = e[11];
  let g;
  e[12] !== s ? (g = /* @__PURE__ */ c.jsx(Zn, { asChild: !0, children: /* @__PURE__ */ c.jsxs(Fe, { className: "block w-full", href: m, as: "button", onClick: s, "data-test": "logout-button", children: [
    h,
    "Log out"
  ] }) }), e[12] = s, e[13] = g) : g = e[13];
  let v;
  return e[14] !== g || e[15] !== a || e[16] !== d ? (v = /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
    a,
    i,
    d,
    p,
    g
  ] }), e[14] = g, e[15] = a, e[16] = d, e[17] = v) : v = e[17], v;
}
function zd() {
  const t = A.c(13), {
    auth: e
  } = tn().props, {
    state: n
  } = Rt(), r = lr();
  let o;
  t[0] !== e.user ? (o = /* @__PURE__ */ c.jsx(xs, { user: e.user }), t[0] = e.user, t[1] = o) : o = t[1];
  let s;
  t[2] === Symbol.for("react.memo_cache_sentinel") ? (s = /* @__PURE__ */ c.jsx(Hs, { className: "ml-auto size-4" }), t[2] = s) : s = t[2];
  let a;
  t[3] !== o ? (a = /* @__PURE__ */ c.jsx(Cd, { asChild: !0, children: /* @__PURE__ */ c.jsxs(Pt, { size: "lg", className: "group text-sidebar-accent-foreground data-[state=open]:bg-sidebar-accent", "data-test": "sidebar-menu-button", children: [
    o,
    s
  ] }) }), t[3] = o, t[4] = a) : a = t[4];
  const i = r ? "bottom" : n === "collapsed" ? "left" : "bottom";
  let l;
  t[5] !== e.user ? (l = /* @__PURE__ */ c.jsx(Vd, { user: e.user }), t[5] = e.user, t[6] = l) : l = t[6];
  let f;
  t[7] !== i || t[8] !== l ? (f = /* @__PURE__ */ c.jsx(Sd, { className: "w-(--radix-dropdown-menu-trigger-width) min-w-56 rounded-lg", align: "end", side: i, children: l }), t[7] = i, t[8] = l, t[9] = f) : f = t[9];
  let d;
  return t[10] !== a || t[11] !== f ? (d = /* @__PURE__ */ c.jsx(At, { children: /* @__PURE__ */ c.jsx(Mt, { children: /* @__PURE__ */ c.jsxs(Ed, { children: [
    a,
    f
  ] }) }) }), t[10] = a, t[11] = f, t[12] = d) : d = t[12], d;
}
function Yd() {
  const t = A.c(2);
  let e;
  t[0] === Symbol.for("react.memo_cache_sentinel") ? (e = /* @__PURE__ */ c.jsx("div", { className: "flex aspect-square size-8 items-center justify-center rounded-md bg-sidebar-primary text-sidebar-primary-foreground", children: /* @__PURE__ */ c.jsx(Ps, { className: "size-5 fill-current text-white dark:text-black" }) }), t[0] = e) : e = t[0];
  let n;
  return t[1] === Symbol.for("react.memo_cache_sentinel") ? (n = /* @__PURE__ */ c.jsxs(c.Fragment, { children: [
    e,
    /* @__PURE__ */ c.jsx("div", { className: "ml-1 grid flex-1 text-left text-sm", children: /* @__PURE__ */ c.jsx("span", { className: "mb-0.5 truncate leading-tight font-semibold", children: "Laravel Starter Kit" }) })
  ] }), t[1] = n) : n = t[1], n;
}
const qd = [{
  title: "Dashboard",
  href: cr(),
  icon: Us
}], Xd = [{
  title: "Repository",
  href: "https://github.com/laravel/react-starter-kit",
  icon: Gs
}, {
  title: "Documentation",
  href: "https://laravel.com/docs/starter-kits#react",
  icon: ks
}];
function Qd() {
  const t = A.c(4);
  let e;
  t[0] === Symbol.for("react.memo_cache_sentinel") ? (e = cr(), t[0] = e) : e = t[0];
  let n;
  t[1] === Symbol.for("react.memo_cache_sentinel") ? (n = /* @__PURE__ */ c.jsx(Dl, { children: /* @__PURE__ */ c.jsx(At, { children: /* @__PURE__ */ c.jsx(Mt, { children: /* @__PURE__ */ c.jsx(Pt, { size: "lg", asChild: !0, children: /* @__PURE__ */ c.jsx(Fe, { href: e, prefetch: !0, children: /* @__PURE__ */ c.jsx(Yd, {}) }) }) }) }) }), t[1] = n) : n = t[1];
  let r;
  t[2] === Symbol.for("react.memo_cache_sentinel") ? (r = /* @__PURE__ */ c.jsx(Il, { children: /* @__PURE__ */ c.jsx(Kl, { items: qd }) }), t[2] = r) : r = t[2];
  let o;
  return t[3] === Symbol.for("react.memo_cache_sentinel") ? (o = /* @__PURE__ */ c.jsxs(Ol, { collapsible: "icon", variant: "inset", children: [
    n,
    r,
    /* @__PURE__ */ c.jsxs(jl, { children: [
      /* @__PURE__ */ c.jsx(Wl, { items: Xd, className: "mt-auto" }),
      /* @__PURE__ */ c.jsx(zd, {})
    ] })
  ] }), t[3] = o) : o = t[3], o;
}
function Zd(t) {
  const e = A.c(4);
  let n;
  e[0] !== t ? ({
    ...n
  } = t, e[0] = t, e[1] = n) : n = e[1];
  let r;
  return e[2] !== n ? (r = /* @__PURE__ */ c.jsx("nav", { "aria-label": "breadcrumb", "data-slot": "breadcrumb", ...n }), e[2] = n, e[3] = r) : r = e[3], r;
}
function Jd(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("ol", { "data-slot": "breadcrumb-list", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function ef(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("inline-flex items-center gap-1.5", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("li", { "data-slot": "breadcrumb-item", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function tf(t) {
  const e = A.c(10);
  let n, r, o;
  e[0] !== t ? ({
    asChild: n,
    className: r,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  const s = n ? en : "a";
  let a;
  e[4] !== r ? (a = L("hover:text-foreground transition-colors", r), e[4] = r, e[5] = a) : a = e[5];
  let i;
  return e[6] !== s || e[7] !== o || e[8] !== a ? (i = /* @__PURE__ */ c.jsx(s, { "data-slot": "breadcrumb-link", className: a, ...o }), e[6] = s, e[7] = o, e[8] = a, e[9] = i) : i = e[9], i;
}
function nf(t) {
  const e = A.c(8);
  let n, r;
  e[0] !== t ? ({
    className: n,
    ...r
  } = t, e[0] = t, e[1] = n, e[2] = r) : (n = e[1], r = e[2]);
  let o;
  e[3] !== n ? (o = L("text-foreground font-normal", n), e[3] = n, e[4] = o) : o = e[4];
  let s;
  return e[5] !== r || e[6] !== o ? (s = /* @__PURE__ */ c.jsx("span", { "data-slot": "breadcrumb-page", role: "link", "aria-disabled": "true", "aria-current": "page", className: o, ...r }), e[5] = r, e[6] = o, e[7] = s) : s = e[7], s;
}
function rf(t) {
  const e = A.c(12);
  let n, r, o;
  e[0] !== t ? ({
    children: n,
    className: r,
    ...o
  } = t, e[0] = t, e[1] = n, e[2] = r, e[3] = o) : (n = e[1], r = e[2], o = e[3]);
  let s;
  e[4] !== r ? (s = L("[&>svg]:size-3.5", r), e[4] = r, e[5] = s) : s = e[5];
  let a;
  e[6] !== n ? (a = n ?? /* @__PURE__ */ c.jsx($s, {}), e[6] = n, e[7] = a) : a = e[7];
  let i;
  return e[8] !== o || e[9] !== s || e[10] !== a ? (i = /* @__PURE__ */ c.jsx("li", { "data-slot": "breadcrumb-separator", role: "presentation", "aria-hidden": "true", className: s, ...o, children: a }), e[8] = o, e[9] = s, e[10] = a, e[11] = i) : i = e[11], i;
}
function of(t) {
  const e = A.c(4), {
    breadcrumbs: n
  } = t;
  let r;
  e[0] !== n ? (r = n.length > 0 && /* @__PURE__ */ c.jsx(Zd, { children: /* @__PURE__ */ c.jsx(Jd, { children: n.map((s, a) => {
    const i = a === n.length - 1;
    return /* @__PURE__ */ c.jsxs(u.Fragment, { children: [
      /* @__PURE__ */ c.jsx(ef, { children: i ? /* @__PURE__ */ c.jsx(nf, { children: s.title }) : /* @__PURE__ */ c.jsx(tf, { asChild: !0, children: /* @__PURE__ */ c.jsx(Fe, { href: s.href, children: s.title }) }) }),
      !i && /* @__PURE__ */ c.jsx(rf, {})
    ] }, a);
  }) }) }), e[0] = n, e[1] = r) : r = e[1];
  let o;
  return e[2] !== r ? (o = /* @__PURE__ */ c.jsx(c.Fragment, { children: r }), e[2] = r, e[3] = o) : o = e[3], o;
}
function sf(t) {
  const e = A.c(5), {
    breadcrumbs: n
  } = t;
  let r;
  e[0] !== n ? (r = n === void 0 ? [] : n, e[0] = n, e[1] = r) : r = e[1];
  const o = r;
  let s;
  e[2] === Symbol.for("react.memo_cache_sentinel") ? (s = /* @__PURE__ */ c.jsx(Nl, { className: "-ml-1" }), e[2] = s) : s = e[2];
  let a;
  return e[3] !== o ? (a = /* @__PURE__ */ c.jsx("header", { className: "flex h-16 shrink-0 items-center gap-2 border-b border-sidebar-border/50 px-6 transition-[width,height] ease-linear group-has-data-[collapsible=icon]/sidebar-wrapper:h-12 md:px-4", children: /* @__PURE__ */ c.jsxs("div", { className: "flex items-center gap-2", children: [
    s,
    /* @__PURE__ */ c.jsx(of, { breadcrumbs: o })
  ] }) }), e[3] = o, e[4] = a) : a = e[4], a;
}
function af(t) {
  const e = A.c(8), {
    children: n,
    breadcrumbs: r
  } = t;
  let o;
  e[0] !== r ? (o = r === void 0 ? [] : r, e[0] = r, e[1] = o) : o = e[1];
  const s = o;
  let a;
  e[2] === Symbol.for("react.memo_cache_sentinel") ? (a = /* @__PURE__ */ c.jsx(Qd, {}), e[2] = a) : a = e[2];
  let i;
  e[3] !== s ? (i = /* @__PURE__ */ c.jsx(sf, { breadcrumbs: s }), e[3] = s, e[4] = i) : i = e[4];
  let l;
  return e[5] !== n || e[6] !== i ? (l = /* @__PURE__ */ c.jsxs(Bl, { variant: "sidebar", children: [
    a,
    /* @__PURE__ */ c.jsxs($l, { variant: "sidebar", className: "overflow-x-hidden", children: [
      i,
      n
    ] })
  ] }), e[5] = n, e[6] = i, e[7] = l) : l = e[7], l;
}
const Ef = ({
  children: t,
  breadcrumbs: e,
  ...n
}) => /* @__PURE__ */ c.jsx(af, { breadcrumbs: e, ...n, children: t });
export {
  Ef as A,
  bi as C,
  wi as D,
  xi as O,
  gi as P,
  vi as R,
  yi as T,
  Js as X,
  Ei as a,
  gf as b,
  U as e
};
